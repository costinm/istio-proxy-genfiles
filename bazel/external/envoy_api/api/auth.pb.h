// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/auth.proto

#ifndef PROTOBUF_api_2fauth_2eproto__INCLUDED
#define PROTOBUF_api_2fauth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api/sds.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_api_2fauth_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAuthAction_AndRuleImpl();
void InitDefaultsAuthAction_AndRule();
void InitDefaultsAuthAction_X509RuleImpl();
void InitDefaultsAuthAction_X509Rule();
void InitDefaultsAuthActionImpl();
void InitDefaultsAuthAction();
inline void InitDefaults() {
  InitDefaultsAuthAction_AndRule();
  InitDefaultsAuthAction_X509Rule();
  InitDefaultsAuthAction();
}
}  // namespace protobuf_api_2fauth_2eproto
namespace envoy {
namespace api {
namespace v2 {
class AuthAction;
class AuthActionDefaultTypeInternal;
extern AuthActionDefaultTypeInternal _AuthAction_default_instance_;
class AuthAction_AndRule;
class AuthAction_AndRuleDefaultTypeInternal;
extern AuthAction_AndRuleDefaultTypeInternal _AuthAction_AndRule_default_instance_;
class AuthAction_OrRule;
class AuthAction_OrRuleDefaultTypeInternal;
extern AuthAction_OrRuleDefaultTypeInternal _AuthAction_OrRule_default_instance_;
class AuthAction_Rule;
class AuthAction_RuleDefaultTypeInternal;
extern AuthAction_RuleDefaultTypeInternal _AuthAction_Rule_default_instance_;
class AuthAction_X509Rule;
class AuthAction_X509RuleDefaultTypeInternal;
extern AuthAction_X509RuleDefaultTypeInternal _AuthAction_X509Rule_default_instance_;
}  // namespace v2
}  // namespace api
}  // namespace envoy
namespace envoy {
namespace api {
namespace v2 {

enum AuthAction_ActionType {
  AuthAction_ActionType_ALLOW = 0,
  AuthAction_ActionType_DENY = 1,
  AuthAction_ActionType_AuthAction_ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthAction_ActionType_AuthAction_ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthAction_ActionType_IsValid(int value);
const AuthAction_ActionType AuthAction_ActionType_ActionType_MIN = AuthAction_ActionType_ALLOW;
const AuthAction_ActionType AuthAction_ActionType_ActionType_MAX = AuthAction_ActionType_DENY;
const int AuthAction_ActionType_ActionType_ARRAYSIZE = AuthAction_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthAction_ActionType_descriptor();
inline const ::std::string& AuthAction_ActionType_Name(AuthAction_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthAction_ActionType_descriptor(), value);
}
inline bool AuthAction_ActionType_Parse(
    const ::std::string& name, AuthAction_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthAction_ActionType>(
    AuthAction_ActionType_descriptor(), name, value);
}
// ===================================================================

class AuthAction_AndRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.AuthAction.AndRule) */ {
 public:
  AuthAction_AndRule();
  virtual ~AuthAction_AndRule();

  AuthAction_AndRule(const AuthAction_AndRule& from);

  inline AuthAction_AndRule& operator=(const AuthAction_AndRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthAction_AndRule(AuthAction_AndRule&& from) noexcept
    : AuthAction_AndRule() {
    *this = ::std::move(from);
  }

  inline AuthAction_AndRule& operator=(AuthAction_AndRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAction_AndRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthAction_AndRule* internal_default_instance() {
    return reinterpret_cast<const AuthAction_AndRule*>(
               &_AuthAction_AndRule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AuthAction_AndRule* other);
  friend void swap(AuthAction_AndRule& a, AuthAction_AndRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthAction_AndRule* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthAction_AndRule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthAction_AndRule& from);
  void MergeFrom(const AuthAction_AndRule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthAction_AndRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.AuthAction.Rule rules = 1;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 1;
  const ::envoy::api::v2::AuthAction_Rule& rules(int index) const;
  ::envoy::api::v2::AuthAction_Rule* mutable_rules(int index);
  ::envoy::api::v2::AuthAction_Rule* add_rules();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
      mutable_rules();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.AuthAction.AndRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule > rules_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2fauth_2eproto::TableStruct;
  friend void ::protobuf_api_2fauth_2eproto::InitDefaultsAuthAction_AndRuleImpl();
};
// -------------------------------------------------------------------

class AuthAction_OrRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.AuthAction.OrRule) */ {
 public:
  AuthAction_OrRule();
  virtual ~AuthAction_OrRule();

  AuthAction_OrRule(const AuthAction_OrRule& from);

  inline AuthAction_OrRule& operator=(const AuthAction_OrRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthAction_OrRule(AuthAction_OrRule&& from) noexcept
    : AuthAction_OrRule() {
    *this = ::std::move(from);
  }

  inline AuthAction_OrRule& operator=(AuthAction_OrRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAction_OrRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthAction_OrRule* internal_default_instance() {
    return reinterpret_cast<const AuthAction_OrRule*>(
               &_AuthAction_OrRule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AuthAction_OrRule* other);
  friend void swap(AuthAction_OrRule& a, AuthAction_OrRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthAction_OrRule* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthAction_OrRule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthAction_OrRule& from);
  void MergeFrom(const AuthAction_OrRule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthAction_OrRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.AuthAction.Rule rules = 1;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 1;
  const ::envoy::api::v2::AuthAction_Rule& rules(int index) const;
  ::envoy::api::v2::AuthAction_Rule* mutable_rules(int index);
  ::envoy::api::v2::AuthAction_Rule* add_rules();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
      mutable_rules();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.AuthAction.OrRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule > rules_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2fauth_2eproto::TableStruct;
  friend void ::protobuf_api_2fauth_2eproto::InitDefaultsAuthAction_AndRuleImpl();
};
// -------------------------------------------------------------------

class AuthAction_X509Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.AuthAction.X509Rule) */ {
 public:
  AuthAction_X509Rule();
  virtual ~AuthAction_X509Rule();

  AuthAction_X509Rule(const AuthAction_X509Rule& from);

  inline AuthAction_X509Rule& operator=(const AuthAction_X509Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthAction_X509Rule(AuthAction_X509Rule&& from) noexcept
    : AuthAction_X509Rule() {
    *this = ::std::move(from);
  }

  inline AuthAction_X509Rule& operator=(AuthAction_X509Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAction_X509Rule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthAction_X509Rule* internal_default_instance() {
    return reinterpret_cast<const AuthAction_X509Rule*>(
               &_AuthAction_X509Rule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AuthAction_X509Rule* other);
  friend void swap(AuthAction_X509Rule& a, AuthAction_X509Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthAction_X509Rule* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthAction_X509Rule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthAction_X509Rule& from);
  void MergeFrom(const AuthAction_X509Rule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthAction_X509Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.CertificateValidationContext validation_context = 3;
  bool has_validation_context() const;
  void clear_validation_context();
  static const int kValidationContextFieldNumber = 3;
  const ::envoy::api::v2::CertificateValidationContext& validation_context() const;
  ::envoy::api::v2::CertificateValidationContext* release_validation_context();
  ::envoy::api::v2::CertificateValidationContext* mutable_validation_context();
  void set_allocated_validation_context(::envoy::api::v2::CertificateValidationContext* validation_context);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.AuthAction.X509Rule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::CertificateValidationContext* validation_context_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2fauth_2eproto::TableStruct;
  friend void ::protobuf_api_2fauth_2eproto::InitDefaultsAuthAction_X509RuleImpl();
};
// -------------------------------------------------------------------

class AuthAction_Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.AuthAction.Rule) */ {
 public:
  AuthAction_Rule();
  virtual ~AuthAction_Rule();

  AuthAction_Rule(const AuthAction_Rule& from);

  inline AuthAction_Rule& operator=(const AuthAction_Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthAction_Rule(AuthAction_Rule&& from) noexcept
    : AuthAction_Rule() {
    *this = ::std::move(from);
  }

  inline AuthAction_Rule& operator=(AuthAction_Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAction_Rule& default_instance();

  enum RuleSpecifierCase {
    kAndRule = 1,
    kOrRule = 2,
    kX509Rule = 3,
    RULE_SPECIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthAction_Rule* internal_default_instance() {
    return reinterpret_cast<const AuthAction_Rule*>(
               &_AuthAction_Rule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AuthAction_Rule* other);
  friend void swap(AuthAction_Rule& a, AuthAction_Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthAction_Rule* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthAction_Rule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthAction_Rule& from);
  void MergeFrom(const AuthAction_Rule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthAction_Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.AuthAction.AndRule and_rule = 1;
  bool has_and_rule() const;
  void clear_and_rule();
  static const int kAndRuleFieldNumber = 1;
  const ::envoy::api::v2::AuthAction_AndRule& and_rule() const;
  ::envoy::api::v2::AuthAction_AndRule* release_and_rule();
  ::envoy::api::v2::AuthAction_AndRule* mutable_and_rule();
  void set_allocated_and_rule(::envoy::api::v2::AuthAction_AndRule* and_rule);

  // .envoy.api.v2.AuthAction.OrRule or_rule = 2;
  bool has_or_rule() const;
  void clear_or_rule();
  static const int kOrRuleFieldNumber = 2;
  const ::envoy::api::v2::AuthAction_OrRule& or_rule() const;
  ::envoy::api::v2::AuthAction_OrRule* release_or_rule();
  ::envoy::api::v2::AuthAction_OrRule* mutable_or_rule();
  void set_allocated_or_rule(::envoy::api::v2::AuthAction_OrRule* or_rule);

  // .envoy.api.v2.AuthAction.X509Rule x509_rule = 3;
  bool has_x509_rule() const;
  void clear_x509_rule();
  static const int kX509RuleFieldNumber = 3;
  const ::envoy::api::v2::AuthAction_X509Rule& x509_rule() const;
  ::envoy::api::v2::AuthAction_X509Rule* release_x509_rule();
  ::envoy::api::v2::AuthAction_X509Rule* mutable_x509_rule();
  void set_allocated_x509_rule(::envoy::api::v2::AuthAction_X509Rule* x509_rule);

  RuleSpecifierCase rule_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.AuthAction.Rule)
 private:
  void set_has_and_rule();
  void set_has_or_rule();
  void set_has_x509_rule();

  inline bool has_rule_specifier() const;
  void clear_rule_specifier();
  inline void clear_has_rule_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RuleSpecifierUnion {
    RuleSpecifierUnion() {}
    ::envoy::api::v2::AuthAction_AndRule* and_rule_;
    ::envoy::api::v2::AuthAction_OrRule* or_rule_;
    ::envoy::api::v2::AuthAction_X509Rule* x509_rule_;
  } rule_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_api_2fauth_2eproto::TableStruct;
  friend void ::protobuf_api_2fauth_2eproto::InitDefaultsAuthAction_AndRuleImpl();
};
// -------------------------------------------------------------------

class AuthAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.AuthAction) */ {
 public:
  AuthAction();
  virtual ~AuthAction();

  AuthAction(const AuthAction& from);

  inline AuthAction& operator=(const AuthAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthAction(AuthAction&& from) noexcept
    : AuthAction() {
    *this = ::std::move(from);
  }

  inline AuthAction& operator=(AuthAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthAction* internal_default_instance() {
    return reinterpret_cast<const AuthAction*>(
               &_AuthAction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AuthAction* other);
  friend void swap(AuthAction& a, AuthAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthAction* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthAction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthAction& from);
  void MergeFrom(const AuthAction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AuthAction_AndRule AndRule;
  typedef AuthAction_OrRule OrRule;
  typedef AuthAction_X509Rule X509Rule;
  typedef AuthAction_Rule Rule;

  typedef AuthAction_ActionType ActionType;
  static const ActionType ALLOW =
    AuthAction_ActionType_ALLOW;
  static const ActionType DENY =
    AuthAction_ActionType_DENY;
  static inline bool ActionType_IsValid(int value) {
    return AuthAction_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    AuthAction_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    AuthAction_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    AuthAction_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return AuthAction_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return AuthAction_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return AuthAction_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.AuthAction.Rule rule = 2;
  int rule_size() const;
  void clear_rule();
  static const int kRuleFieldNumber = 2;
  const ::envoy::api::v2::AuthAction_Rule& rule(int index) const;
  ::envoy::api::v2::AuthAction_Rule* mutable_rule(int index);
  ::envoy::api::v2::AuthAction_Rule* add_rule();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
      mutable_rule();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
      rule() const;

  // .envoy.api.v2.AuthAction.ActionType action_type = 1;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 1;
  ::envoy::api::v2::AuthAction_ActionType action_type() const;
  void set_action_type(::envoy::api::v2::AuthAction_ActionType value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.AuthAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule > rule_;
  int action_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2fauth_2eproto::TableStruct;
  friend void ::protobuf_api_2fauth_2eproto::InitDefaultsAuthActionImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthAction_AndRule

// repeated .envoy.api.v2.AuthAction.Rule rules = 1;
inline int AuthAction_AndRule::rules_size() const {
  return rules_.size();
}
inline void AuthAction_AndRule::clear_rules() {
  rules_.Clear();
}
inline const ::envoy::api::v2::AuthAction_Rule& AuthAction_AndRule::rules(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.AndRule.rules)
  return rules_.Get(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction_AndRule::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.AndRule.rules)
  return rules_.Mutable(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction_AndRule::add_rules() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.AuthAction.AndRule.rules)
  return rules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
AuthAction_AndRule::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.AuthAction.AndRule.rules)
  return &rules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
AuthAction_AndRule::rules() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.AuthAction.AndRule.rules)
  return rules_;
}

// -------------------------------------------------------------------

// AuthAction_OrRule

// repeated .envoy.api.v2.AuthAction.Rule rules = 1;
inline int AuthAction_OrRule::rules_size() const {
  return rules_.size();
}
inline void AuthAction_OrRule::clear_rules() {
  rules_.Clear();
}
inline const ::envoy::api::v2::AuthAction_Rule& AuthAction_OrRule::rules(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.OrRule.rules)
  return rules_.Get(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction_OrRule::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.OrRule.rules)
  return rules_.Mutable(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction_OrRule::add_rules() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.AuthAction.OrRule.rules)
  return rules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
AuthAction_OrRule::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.AuthAction.OrRule.rules)
  return &rules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
AuthAction_OrRule::rules() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.AuthAction.OrRule.rules)
  return rules_;
}

// -------------------------------------------------------------------

// AuthAction_X509Rule

// .envoy.api.v2.CertificateValidationContext validation_context = 3;
inline bool AuthAction_X509Rule::has_validation_context() const {
  return this != internal_default_instance() && validation_context_ != NULL;
}
inline const ::envoy::api::v2::CertificateValidationContext& AuthAction_X509Rule::validation_context() const {
  const ::envoy::api::v2::CertificateValidationContext* p = validation_context_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.X509Rule.validation_context)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::CertificateValidationContext*>(
      &::envoy::api::v2::_CertificateValidationContext_default_instance_);
}
inline ::envoy::api::v2::CertificateValidationContext* AuthAction_X509Rule::release_validation_context() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.AuthAction.X509Rule.validation_context)
  
  ::envoy::api::v2::CertificateValidationContext* temp = validation_context_;
  validation_context_ = NULL;
  return temp;
}
inline ::envoy::api::v2::CertificateValidationContext* AuthAction_X509Rule::mutable_validation_context() {
  
  if (validation_context_ == NULL) {
    validation_context_ = new ::envoy::api::v2::CertificateValidationContext;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.X509Rule.validation_context)
  return validation_context_;
}
inline void AuthAction_X509Rule::set_allocated_validation_context(::envoy::api::v2::CertificateValidationContext* validation_context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(validation_context_);
  }
  if (validation_context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      validation_context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validation_context, submessage_arena);
    }
    
  } else {
    
  }
  validation_context_ = validation_context;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.AuthAction.X509Rule.validation_context)
}

// -------------------------------------------------------------------

// AuthAction_Rule

// .envoy.api.v2.AuthAction.AndRule and_rule = 1;
inline bool AuthAction_Rule::has_and_rule() const {
  return rule_specifier_case() == kAndRule;
}
inline void AuthAction_Rule::set_has_and_rule() {
  _oneof_case_[0] = kAndRule;
}
inline void AuthAction_Rule::clear_and_rule() {
  if (has_and_rule()) {
    delete rule_specifier_.and_rule_;
    clear_has_rule_specifier();
  }
}
inline ::envoy::api::v2::AuthAction_AndRule* AuthAction_Rule::release_and_rule() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.AuthAction.Rule.and_rule)
  if (has_and_rule()) {
    clear_has_rule_specifier();
      ::envoy::api::v2::AuthAction_AndRule* temp = rule_specifier_.and_rule_;
    rule_specifier_.and_rule_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::AuthAction_AndRule& AuthAction_Rule::and_rule() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.Rule.and_rule)
  return has_and_rule()
      ? *rule_specifier_.and_rule_
      : *reinterpret_cast< ::envoy::api::v2::AuthAction_AndRule*>(&::envoy::api::v2::_AuthAction_AndRule_default_instance_);
}
inline ::envoy::api::v2::AuthAction_AndRule* AuthAction_Rule::mutable_and_rule() {
  if (!has_and_rule()) {
    clear_rule_specifier();
    set_has_and_rule();
    rule_specifier_.and_rule_ = new ::envoy::api::v2::AuthAction_AndRule;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.Rule.and_rule)
  return rule_specifier_.and_rule_;
}

// .envoy.api.v2.AuthAction.OrRule or_rule = 2;
inline bool AuthAction_Rule::has_or_rule() const {
  return rule_specifier_case() == kOrRule;
}
inline void AuthAction_Rule::set_has_or_rule() {
  _oneof_case_[0] = kOrRule;
}
inline void AuthAction_Rule::clear_or_rule() {
  if (has_or_rule()) {
    delete rule_specifier_.or_rule_;
    clear_has_rule_specifier();
  }
}
inline ::envoy::api::v2::AuthAction_OrRule* AuthAction_Rule::release_or_rule() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.AuthAction.Rule.or_rule)
  if (has_or_rule()) {
    clear_has_rule_specifier();
      ::envoy::api::v2::AuthAction_OrRule* temp = rule_specifier_.or_rule_;
    rule_specifier_.or_rule_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::AuthAction_OrRule& AuthAction_Rule::or_rule() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.Rule.or_rule)
  return has_or_rule()
      ? *rule_specifier_.or_rule_
      : *reinterpret_cast< ::envoy::api::v2::AuthAction_OrRule*>(&::envoy::api::v2::_AuthAction_OrRule_default_instance_);
}
inline ::envoy::api::v2::AuthAction_OrRule* AuthAction_Rule::mutable_or_rule() {
  if (!has_or_rule()) {
    clear_rule_specifier();
    set_has_or_rule();
    rule_specifier_.or_rule_ = new ::envoy::api::v2::AuthAction_OrRule;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.Rule.or_rule)
  return rule_specifier_.or_rule_;
}

// .envoy.api.v2.AuthAction.X509Rule x509_rule = 3;
inline bool AuthAction_Rule::has_x509_rule() const {
  return rule_specifier_case() == kX509Rule;
}
inline void AuthAction_Rule::set_has_x509_rule() {
  _oneof_case_[0] = kX509Rule;
}
inline void AuthAction_Rule::clear_x509_rule() {
  if (has_x509_rule()) {
    delete rule_specifier_.x509_rule_;
    clear_has_rule_specifier();
  }
}
inline ::envoy::api::v2::AuthAction_X509Rule* AuthAction_Rule::release_x509_rule() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.AuthAction.Rule.x509_rule)
  if (has_x509_rule()) {
    clear_has_rule_specifier();
      ::envoy::api::v2::AuthAction_X509Rule* temp = rule_specifier_.x509_rule_;
    rule_specifier_.x509_rule_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::AuthAction_X509Rule& AuthAction_Rule::x509_rule() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.Rule.x509_rule)
  return has_x509_rule()
      ? *rule_specifier_.x509_rule_
      : *reinterpret_cast< ::envoy::api::v2::AuthAction_X509Rule*>(&::envoy::api::v2::_AuthAction_X509Rule_default_instance_);
}
inline ::envoy::api::v2::AuthAction_X509Rule* AuthAction_Rule::mutable_x509_rule() {
  if (!has_x509_rule()) {
    clear_rule_specifier();
    set_has_x509_rule();
    rule_specifier_.x509_rule_ = new ::envoy::api::v2::AuthAction_X509Rule;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.Rule.x509_rule)
  return rule_specifier_.x509_rule_;
}

inline bool AuthAction_Rule::has_rule_specifier() const {
  return rule_specifier_case() != RULE_SPECIFIER_NOT_SET;
}
inline void AuthAction_Rule::clear_has_rule_specifier() {
  _oneof_case_[0] = RULE_SPECIFIER_NOT_SET;
}
inline AuthAction_Rule::RuleSpecifierCase AuthAction_Rule::rule_specifier_case() const {
  return AuthAction_Rule::RuleSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthAction

// .envoy.api.v2.AuthAction.ActionType action_type = 1;
inline void AuthAction::clear_action_type() {
  action_type_ = 0;
}
inline ::envoy::api::v2::AuthAction_ActionType AuthAction::action_type() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.action_type)
  return static_cast< ::envoy::api::v2::AuthAction_ActionType >(action_type_);
}
inline void AuthAction::set_action_type(::envoy::api::v2::AuthAction_ActionType value) {
  
  action_type_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.AuthAction.action_type)
}

// repeated .envoy.api.v2.AuthAction.Rule rule = 2;
inline int AuthAction::rule_size() const {
  return rule_.size();
}
inline void AuthAction::clear_rule() {
  rule_.Clear();
}
inline const ::envoy::api::v2::AuthAction_Rule& AuthAction::rule(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.AuthAction.rule)
  return rule_.Get(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction::mutable_rule(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.AuthAction.rule)
  return rule_.Mutable(index);
}
inline ::envoy::api::v2::AuthAction_Rule* AuthAction::add_rule() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.AuthAction.rule)
  return rule_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >*
AuthAction::mutable_rule() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.AuthAction.rule)
  return &rule_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::AuthAction_Rule >&
AuthAction::rule() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.AuthAction.rule)
  return rule_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::envoy::api::v2::AuthAction_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::AuthAction_ActionType>() {
  return ::envoy::api::v2::AuthAction_ActionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2fauth_2eproto__INCLUDED
