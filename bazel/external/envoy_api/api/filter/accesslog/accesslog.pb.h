// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/filter/accesslog/accesslog.proto

#ifndef PROTOBUF_api_2ffilter_2faccesslog_2faccesslog_2eproto__INCLUDED
#define PROTOBUF_api_2ffilter_2faccesslog_2faccesslog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api/address.pb.h"
#include "api/base.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[26];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAccessLogCommonImpl();
void InitDefaultsAccessLogCommon();
void InitDefaultsResponseFlagsImpl();
void InitDefaultsResponseFlags();
void InitDefaultsTLSPropertiesImpl();
void InitDefaultsTLSProperties();
void InitDefaultsTCPAccessLogEntryImpl();
void InitDefaultsTCPAccessLogEntry();
void InitDefaultsHTTPRequestProperties_RequestHeadersEntry_DoNotUseImpl();
void InitDefaultsHTTPRequestProperties_RequestHeadersEntry_DoNotUse();
void InitDefaultsHTTPRequestPropertiesImpl();
void InitDefaultsHTTPRequestProperties();
void InitDefaultsHTTPResponseProperties_ResponseHeadersEntry_DoNotUseImpl();
void InitDefaultsHTTPResponseProperties_ResponseHeadersEntry_DoNotUse();
void InitDefaultsHTTPResponsePropertiesImpl();
void InitDefaultsHTTPResponseProperties();
void InitDefaultsHTTPAccessLogEntryImpl();
void InitDefaultsHTTPAccessLogEntry();
void InitDefaultsComparisonFilterImpl();
void InitDefaultsComparisonFilter();
void InitDefaultsStatusCodeFilterImpl();
void InitDefaultsStatusCodeFilter();
void InitDefaultsDurationFilterImpl();
void InitDefaultsDurationFilter();
void InitDefaultsNotHealthCheckFilterImpl();
void InitDefaultsNotHealthCheckFilter();
void InitDefaultsTraceableFilterImpl();
void InitDefaultsTraceableFilter();
void InitDefaultsRuntimeFilterImpl();
void InitDefaultsRuntimeFilter();
void InitDefaultsAccessLogFilterImpl();
void InitDefaultsAccessLogFilter();
void InitDefaultsFileAccessLogImpl();
void InitDefaultsFileAccessLog();
void InitDefaultsAccessLogServiceConfigImpl();
void InitDefaultsAccessLogServiceConfig();
void InitDefaultsStreamAccessLogsMessage_IdentifierImpl();
void InitDefaultsStreamAccessLogsMessage_Identifier();
void InitDefaultsStreamAccessLogsMessage_HTTPAccessLogEntriesImpl();
void InitDefaultsStreamAccessLogsMessage_HTTPAccessLogEntries();
void InitDefaultsStreamAccessLogsMessage_TCPAccessLogEntriesImpl();
void InitDefaultsStreamAccessLogsMessage_TCPAccessLogEntries();
void InitDefaultsStreamAccessLogsMessageImpl();
void InitDefaultsStreamAccessLogsMessage();
void InitDefaultsStreamAccessLogsResponseImpl();
void InitDefaultsStreamAccessLogsResponse();
void InitDefaultsAccessLogImpl();
void InitDefaultsAccessLog();
inline void InitDefaults() {
  InitDefaultsAccessLogCommon();
  InitDefaultsResponseFlags();
  InitDefaultsTLSProperties();
  InitDefaultsTCPAccessLogEntry();
  InitDefaultsHTTPRequestProperties_RequestHeadersEntry_DoNotUse();
  InitDefaultsHTTPRequestProperties();
  InitDefaultsHTTPResponseProperties_ResponseHeadersEntry_DoNotUse();
  InitDefaultsHTTPResponseProperties();
  InitDefaultsHTTPAccessLogEntry();
  InitDefaultsComparisonFilter();
  InitDefaultsStatusCodeFilter();
  InitDefaultsDurationFilter();
  InitDefaultsNotHealthCheckFilter();
  InitDefaultsTraceableFilter();
  InitDefaultsRuntimeFilter();
  InitDefaultsAccessLogFilter();
  InitDefaultsFileAccessLog();
  InitDefaultsAccessLogServiceConfig();
  InitDefaultsStreamAccessLogsMessage_Identifier();
  InitDefaultsStreamAccessLogsMessage_HTTPAccessLogEntries();
  InitDefaultsStreamAccessLogsMessage_TCPAccessLogEntries();
  InitDefaultsStreamAccessLogsMessage();
  InitDefaultsStreamAccessLogsResponse();
  InitDefaultsAccessLog();
}
}  // namespace protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto
namespace envoy {
namespace api {
namespace v2 {
namespace filter {
namespace accesslog {
class AccessLog;
class AccessLogDefaultTypeInternal;
extern AccessLogDefaultTypeInternal _AccessLog_default_instance_;
class AccessLogCommon;
class AccessLogCommonDefaultTypeInternal;
extern AccessLogCommonDefaultTypeInternal _AccessLogCommon_default_instance_;
class AccessLogFilter;
class AccessLogFilterDefaultTypeInternal;
extern AccessLogFilterDefaultTypeInternal _AccessLogFilter_default_instance_;
class AccessLogServiceConfig;
class AccessLogServiceConfigDefaultTypeInternal;
extern AccessLogServiceConfigDefaultTypeInternal _AccessLogServiceConfig_default_instance_;
class AndFilter;
class AndFilterDefaultTypeInternal;
extern AndFilterDefaultTypeInternal _AndFilter_default_instance_;
class ComparisonFilter;
class ComparisonFilterDefaultTypeInternal;
extern ComparisonFilterDefaultTypeInternal _ComparisonFilter_default_instance_;
class DurationFilter;
class DurationFilterDefaultTypeInternal;
extern DurationFilterDefaultTypeInternal _DurationFilter_default_instance_;
class FileAccessLog;
class FileAccessLogDefaultTypeInternal;
extern FileAccessLogDefaultTypeInternal _FileAccessLog_default_instance_;
class HTTPAccessLogEntry;
class HTTPAccessLogEntryDefaultTypeInternal;
extern HTTPAccessLogEntryDefaultTypeInternal _HTTPAccessLogEntry_default_instance_;
class HTTPRequestProperties;
class HTTPRequestPropertiesDefaultTypeInternal;
extern HTTPRequestPropertiesDefaultTypeInternal _HTTPRequestProperties_default_instance_;
class HTTPRequestProperties_RequestHeadersEntry_DoNotUse;
class HTTPRequestProperties_RequestHeadersEntry_DoNotUseDefaultTypeInternal;
extern HTTPRequestProperties_RequestHeadersEntry_DoNotUseDefaultTypeInternal _HTTPRequestProperties_RequestHeadersEntry_DoNotUse_default_instance_;
class HTTPResponseProperties;
class HTTPResponsePropertiesDefaultTypeInternal;
extern HTTPResponsePropertiesDefaultTypeInternal _HTTPResponseProperties_default_instance_;
class HTTPResponseProperties_ResponseHeadersEntry_DoNotUse;
class HTTPResponseProperties_ResponseHeadersEntry_DoNotUseDefaultTypeInternal;
extern HTTPResponseProperties_ResponseHeadersEntry_DoNotUseDefaultTypeInternal _HTTPResponseProperties_ResponseHeadersEntry_DoNotUse_default_instance_;
class NotHealthCheckFilter;
class NotHealthCheckFilterDefaultTypeInternal;
extern NotHealthCheckFilterDefaultTypeInternal _NotHealthCheckFilter_default_instance_;
class OrFilter;
class OrFilterDefaultTypeInternal;
extern OrFilterDefaultTypeInternal _OrFilter_default_instance_;
class ResponseFlags;
class ResponseFlagsDefaultTypeInternal;
extern ResponseFlagsDefaultTypeInternal _ResponseFlags_default_instance_;
class RuntimeFilter;
class RuntimeFilterDefaultTypeInternal;
extern RuntimeFilterDefaultTypeInternal _RuntimeFilter_default_instance_;
class StatusCodeFilter;
class StatusCodeFilterDefaultTypeInternal;
extern StatusCodeFilterDefaultTypeInternal _StatusCodeFilter_default_instance_;
class StreamAccessLogsMessage;
class StreamAccessLogsMessageDefaultTypeInternal;
extern StreamAccessLogsMessageDefaultTypeInternal _StreamAccessLogsMessage_default_instance_;
class StreamAccessLogsMessage_HTTPAccessLogEntries;
class StreamAccessLogsMessage_HTTPAccessLogEntriesDefaultTypeInternal;
extern StreamAccessLogsMessage_HTTPAccessLogEntriesDefaultTypeInternal _StreamAccessLogsMessage_HTTPAccessLogEntries_default_instance_;
class StreamAccessLogsMessage_Identifier;
class StreamAccessLogsMessage_IdentifierDefaultTypeInternal;
extern StreamAccessLogsMessage_IdentifierDefaultTypeInternal _StreamAccessLogsMessage_Identifier_default_instance_;
class StreamAccessLogsMessage_TCPAccessLogEntries;
class StreamAccessLogsMessage_TCPAccessLogEntriesDefaultTypeInternal;
extern StreamAccessLogsMessage_TCPAccessLogEntriesDefaultTypeInternal _StreamAccessLogsMessage_TCPAccessLogEntries_default_instance_;
class StreamAccessLogsResponse;
class StreamAccessLogsResponseDefaultTypeInternal;
extern StreamAccessLogsResponseDefaultTypeInternal _StreamAccessLogsResponse_default_instance_;
class TCPAccessLogEntry;
class TCPAccessLogEntryDefaultTypeInternal;
extern TCPAccessLogEntryDefaultTypeInternal _TCPAccessLogEntry_default_instance_;
class TLSProperties;
class TLSPropertiesDefaultTypeInternal;
extern TLSPropertiesDefaultTypeInternal _TLSProperties_default_instance_;
class TraceableFilter;
class TraceableFilterDefaultTypeInternal;
extern TraceableFilterDefaultTypeInternal _TraceableFilter_default_instance_;
}  // namespace accesslog
}  // namespace filter
}  // namespace v2
}  // namespace api
}  // namespace envoy
namespace envoy {
namespace api {
namespace v2 {
namespace filter {
namespace accesslog {

enum TLSProperties_TLSVersion {
  TLSProperties_TLSVersion_VERSION_UNSPECIFIED = 0,
  TLSProperties_TLSVersion_TLSv1 = 1,
  TLSProperties_TLSVersion_TLSv1_1 = 2,
  TLSProperties_TLSVersion_TLSv1_2 = 3,
  TLSProperties_TLSVersion_TLSv1_3 = 4,
  TLSProperties_TLSVersion_TLSProperties_TLSVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TLSProperties_TLSVersion_TLSProperties_TLSVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TLSProperties_TLSVersion_IsValid(int value);
const TLSProperties_TLSVersion TLSProperties_TLSVersion_TLSVersion_MIN = TLSProperties_TLSVersion_VERSION_UNSPECIFIED;
const TLSProperties_TLSVersion TLSProperties_TLSVersion_TLSVersion_MAX = TLSProperties_TLSVersion_TLSv1_3;
const int TLSProperties_TLSVersion_TLSVersion_ARRAYSIZE = TLSProperties_TLSVersion_TLSVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* TLSProperties_TLSVersion_descriptor();
inline const ::std::string& TLSProperties_TLSVersion_Name(TLSProperties_TLSVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    TLSProperties_TLSVersion_descriptor(), value);
}
inline bool TLSProperties_TLSVersion_Parse(
    const ::std::string& name, TLSProperties_TLSVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TLSProperties_TLSVersion>(
    TLSProperties_TLSVersion_descriptor(), name, value);
}
enum HTTPAccessLogEntry_HTTPVersion {
  HTTPAccessLogEntry_HTTPVersion_PROTOCOL_UNSPECIFIED = 0,
  HTTPAccessLogEntry_HTTPVersion_HTTP10 = 1,
  HTTPAccessLogEntry_HTTPVersion_HTTP11 = 2,
  HTTPAccessLogEntry_HTTPVersion_HTTP2 = 3,
  HTTPAccessLogEntry_HTTPVersion_HTTPAccessLogEntry_HTTPVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HTTPAccessLogEntry_HTTPVersion_HTTPAccessLogEntry_HTTPVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HTTPAccessLogEntry_HTTPVersion_IsValid(int value);
const HTTPAccessLogEntry_HTTPVersion HTTPAccessLogEntry_HTTPVersion_HTTPVersion_MIN = HTTPAccessLogEntry_HTTPVersion_PROTOCOL_UNSPECIFIED;
const HTTPAccessLogEntry_HTTPVersion HTTPAccessLogEntry_HTTPVersion_HTTPVersion_MAX = HTTPAccessLogEntry_HTTPVersion_HTTP2;
const int HTTPAccessLogEntry_HTTPVersion_HTTPVersion_ARRAYSIZE = HTTPAccessLogEntry_HTTPVersion_HTTPVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* HTTPAccessLogEntry_HTTPVersion_descriptor();
inline const ::std::string& HTTPAccessLogEntry_HTTPVersion_Name(HTTPAccessLogEntry_HTTPVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    HTTPAccessLogEntry_HTTPVersion_descriptor(), value);
}
inline bool HTTPAccessLogEntry_HTTPVersion_Parse(
    const ::std::string& name, HTTPAccessLogEntry_HTTPVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HTTPAccessLogEntry_HTTPVersion>(
    HTTPAccessLogEntry_HTTPVersion_descriptor(), name, value);
}
enum ComparisonFilter_Op {
  ComparisonFilter_Op_EQ = 0,
  ComparisonFilter_Op_GE = 1,
  ComparisonFilter_Op_ComparisonFilter_Op_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ComparisonFilter_Op_ComparisonFilter_Op_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ComparisonFilter_Op_IsValid(int value);
const ComparisonFilter_Op ComparisonFilter_Op_Op_MIN = ComparisonFilter_Op_EQ;
const ComparisonFilter_Op ComparisonFilter_Op_Op_MAX = ComparisonFilter_Op_GE;
const int ComparisonFilter_Op_Op_ARRAYSIZE = ComparisonFilter_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComparisonFilter_Op_descriptor();
inline const ::std::string& ComparisonFilter_Op_Name(ComparisonFilter_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComparisonFilter_Op_descriptor(), value);
}
inline bool ComparisonFilter_Op_Parse(
    const ::std::string& name, ComparisonFilter_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonFilter_Op>(
    ComparisonFilter_Op_descriptor(), name, value);
}
// ===================================================================

class AccessLogCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.AccessLogCommon) */ {
 public:
  AccessLogCommon();
  virtual ~AccessLogCommon();

  AccessLogCommon(const AccessLogCommon& from);

  inline AccessLogCommon& operator=(const AccessLogCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLogCommon(AccessLogCommon&& from) noexcept
    : AccessLogCommon() {
    *this = ::std::move(from);
  }

  inline AccessLogCommon& operator=(AccessLogCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLogCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLogCommon* internal_default_instance() {
    return reinterpret_cast<const AccessLogCommon*>(
               &_AccessLogCommon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AccessLogCommon* other);
  friend void swap(AccessLogCommon& a, AccessLogCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLogCommon* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLogCommon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLogCommon& from);
  void MergeFrom(const AccessLogCommon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLogCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string upstream_cluster = 9;
  void clear_upstream_cluster();
  static const int kUpstreamClusterFieldNumber = 9;
  const ::std::string& upstream_cluster() const;
  void set_upstream_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_upstream_cluster(::std::string&& value);
  #endif
  void set_upstream_cluster(const char* value);
  void set_upstream_cluster(const char* value, size_t size);
  ::std::string* mutable_upstream_cluster();
  ::std::string* release_upstream_cluster();
  void set_allocated_upstream_cluster(::std::string* upstream_cluster);

  // .envoy.api.v2.SocketAddress destination_host = 2;
  bool has_destination_host() const;
  void clear_destination_host();
  static const int kDestinationHostFieldNumber = 2;
  const ::envoy::api::v2::SocketAddress& destination_host() const;
  ::envoy::api::v2::SocketAddress* release_destination_host();
  ::envoy::api::v2::SocketAddress* mutable_destination_host();
  void set_allocated_destination_host(::envoy::api::v2::SocketAddress* destination_host);

  // .envoy.api.v2.filter.accesslog.TLSProperties tls_properties = 3;
  bool has_tls_properties() const;
  void clear_tls_properties();
  static const int kTlsPropertiesFieldNumber = 3;
  const ::envoy::api::v2::filter::accesslog::TLSProperties& tls_properties() const;
  ::envoy::api::v2::filter::accesslog::TLSProperties* release_tls_properties();
  ::envoy::api::v2::filter::accesslog::TLSProperties* mutable_tls_properties();
  void set_allocated_tls_properties(::envoy::api::v2::filter::accesslog::TLSProperties* tls_properties);

  // .google.protobuf.Timestamp start_time = 4;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  const ::google::protobuf::Timestamp& start_time() const;
  ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* start_time);

  // .google.protobuf.Duration time_to_last_rx_byte = 5;
  bool has_time_to_last_rx_byte() const;
  void clear_time_to_last_rx_byte();
  static const int kTimeToLastRxByteFieldNumber = 5;
  const ::google::protobuf::Duration& time_to_last_rx_byte() const;
  ::google::protobuf::Duration* release_time_to_last_rx_byte();
  ::google::protobuf::Duration* mutable_time_to_last_rx_byte();
  void set_allocated_time_to_last_rx_byte(::google::protobuf::Duration* time_to_last_rx_byte);

  // .google.protobuf.Duration time_to_first_upstream_rx_byte = 6;
  bool has_time_to_first_upstream_rx_byte() const;
  void clear_time_to_first_upstream_rx_byte();
  static const int kTimeToFirstUpstreamRxByteFieldNumber = 6;
  const ::google::protobuf::Duration& time_to_first_upstream_rx_byte() const;
  ::google::protobuf::Duration* release_time_to_first_upstream_rx_byte();
  ::google::protobuf::Duration* mutable_time_to_first_upstream_rx_byte();
  void set_allocated_time_to_first_upstream_rx_byte(::google::protobuf::Duration* time_to_first_upstream_rx_byte);

  // .google.protobuf.Duration time_to_last_upstream_rx_byte = 7;
  bool has_time_to_last_upstream_rx_byte() const;
  void clear_time_to_last_upstream_rx_byte();
  static const int kTimeToLastUpstreamRxByteFieldNumber = 7;
  const ::google::protobuf::Duration& time_to_last_upstream_rx_byte() const;
  ::google::protobuf::Duration* release_time_to_last_upstream_rx_byte();
  ::google::protobuf::Duration* mutable_time_to_last_upstream_rx_byte();
  void set_allocated_time_to_last_upstream_rx_byte(::google::protobuf::Duration* time_to_last_upstream_rx_byte);

  // .envoy.api.v2.SocketAddress upstream_host = 8;
  bool has_upstream_host() const;
  void clear_upstream_host();
  static const int kUpstreamHostFieldNumber = 8;
  const ::envoy::api::v2::SocketAddress& upstream_host() const;
  ::envoy::api::v2::SocketAddress* release_upstream_host();
  ::envoy::api::v2::SocketAddress* mutable_upstream_host();
  void set_allocated_upstream_host(::envoy::api::v2::SocketAddress* upstream_host);

  // .envoy.api.v2.filter.accesslog.ResponseFlags response_flags = 10;
  bool has_response_flags() const;
  void clear_response_flags();
  static const int kResponseFlagsFieldNumber = 10;
  const ::envoy::api::v2::filter::accesslog::ResponseFlags& response_flags() const;
  ::envoy::api::v2::filter::accesslog::ResponseFlags* release_response_flags();
  ::envoy::api::v2::filter::accesslog::ResponseFlags* mutable_response_flags();
  void set_allocated_response_flags(::envoy::api::v2::filter::accesslog::ResponseFlags* response_flags);

  // .envoy.api.v2.Metadata metadata = 11;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 11;
  const ::envoy::api::v2::Metadata& metadata() const;
  ::envoy::api::v2::Metadata* release_metadata();
  ::envoy::api::v2::Metadata* mutable_metadata();
  void set_allocated_metadata(::envoy::api::v2::Metadata* metadata);

  // double sample_rate = 1 [(.validate.rules) = {
  void clear_sample_rate();
  static const int kSampleRateFieldNumber = 1;
  double sample_rate() const;
  void set_sample_rate(double value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.AccessLogCommon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr upstream_cluster_;
  ::envoy::api::v2::SocketAddress* destination_host_;
  ::envoy::api::v2::filter::accesslog::TLSProperties* tls_properties_;
  ::google::protobuf::Timestamp* start_time_;
  ::google::protobuf::Duration* time_to_last_rx_byte_;
  ::google::protobuf::Duration* time_to_first_upstream_rx_byte_;
  ::google::protobuf::Duration* time_to_last_upstream_rx_byte_;
  ::envoy::api::v2::SocketAddress* upstream_host_;
  ::envoy::api::v2::filter::accesslog::ResponseFlags* response_flags_;
  ::envoy::api::v2::Metadata* metadata_;
  double sample_rate_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogCommonImpl();
};
// -------------------------------------------------------------------

class ResponseFlags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.ResponseFlags) */ {
 public:
  ResponseFlags();
  virtual ~ResponseFlags();

  ResponseFlags(const ResponseFlags& from);

  inline ResponseFlags& operator=(const ResponseFlags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseFlags(ResponseFlags&& from) noexcept
    : ResponseFlags() {
    *this = ::std::move(from);
  }

  inline ResponseFlags& operator=(ResponseFlags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFlags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseFlags* internal_default_instance() {
    return reinterpret_cast<const ResponseFlags*>(
               &_ResponseFlags_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ResponseFlags* other);
  friend void swap(ResponseFlags& a, ResponseFlags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseFlags* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseFlags* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseFlags& from);
  void MergeFrom(const ResponseFlags& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseFlags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool failed_local_healthcheck = 1;
  void clear_failed_local_healthcheck();
  static const int kFailedLocalHealthcheckFieldNumber = 1;
  bool failed_local_healthcheck() const;
  void set_failed_local_healthcheck(bool value);

  // bool no_healthy_upstream = 2;
  void clear_no_healthy_upstream();
  static const int kNoHealthyUpstreamFieldNumber = 2;
  bool no_healthy_upstream() const;
  void set_no_healthy_upstream(bool value);

  // bool upstream_request_timeout = 3;
  void clear_upstream_request_timeout();
  static const int kUpstreamRequestTimeoutFieldNumber = 3;
  bool upstream_request_timeout() const;
  void set_upstream_request_timeout(bool value);

  // bool local_reset = 4;
  void clear_local_reset();
  static const int kLocalResetFieldNumber = 4;
  bool local_reset() const;
  void set_local_reset(bool value);

  // bool upstream_remote_reset = 5;
  void clear_upstream_remote_reset();
  static const int kUpstreamRemoteResetFieldNumber = 5;
  bool upstream_remote_reset() const;
  void set_upstream_remote_reset(bool value);

  // bool upstream_connection_failure = 6;
  void clear_upstream_connection_failure();
  static const int kUpstreamConnectionFailureFieldNumber = 6;
  bool upstream_connection_failure() const;
  void set_upstream_connection_failure(bool value);

  // bool upstream_connection_termination = 7;
  void clear_upstream_connection_termination();
  static const int kUpstreamConnectionTerminationFieldNumber = 7;
  bool upstream_connection_termination() const;
  void set_upstream_connection_termination(bool value);

  // bool upstream_overflow = 8;
  void clear_upstream_overflow();
  static const int kUpstreamOverflowFieldNumber = 8;
  bool upstream_overflow() const;
  void set_upstream_overflow(bool value);

  // bool no_route_found = 9;
  void clear_no_route_found();
  static const int kNoRouteFoundFieldNumber = 9;
  bool no_route_found() const;
  void set_no_route_found(bool value);

  // bool delay_injected = 10;
  void clear_delay_injected();
  static const int kDelayInjectedFieldNumber = 10;
  bool delay_injected() const;
  void set_delay_injected(bool value);

  // bool fault_injected = 11;
  void clear_fault_injected();
  static const int kFaultInjectedFieldNumber = 11;
  bool fault_injected() const;
  void set_fault_injected(bool value);

  // bool rate_limited = 12;
  void clear_rate_limited();
  static const int kRateLimitedFieldNumber = 12;
  bool rate_limited() const;
  void set_rate_limited(bool value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.ResponseFlags)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool failed_local_healthcheck_;
  bool no_healthy_upstream_;
  bool upstream_request_timeout_;
  bool local_reset_;
  bool upstream_remote_reset_;
  bool upstream_connection_failure_;
  bool upstream_connection_termination_;
  bool upstream_overflow_;
  bool no_route_found_;
  bool delay_injected_;
  bool fault_injected_;
  bool rate_limited_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsResponseFlagsImpl();
};
// -------------------------------------------------------------------

class TLSProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.TLSProperties) */ {
 public:
  TLSProperties();
  virtual ~TLSProperties();

  TLSProperties(const TLSProperties& from);

  inline TLSProperties& operator=(const TLSProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TLSProperties(TLSProperties&& from) noexcept
    : TLSProperties() {
    *this = ::std::move(from);
  }

  inline TLSProperties& operator=(TLSProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TLSProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TLSProperties* internal_default_instance() {
    return reinterpret_cast<const TLSProperties*>(
               &_TLSProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TLSProperties* other);
  friend void swap(TLSProperties& a, TLSProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TLSProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  TLSProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TLSProperties& from);
  void MergeFrom(const TLSProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TLSProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TLSProperties_TLSVersion TLSVersion;
  static const TLSVersion VERSION_UNSPECIFIED =
    TLSProperties_TLSVersion_VERSION_UNSPECIFIED;
  static const TLSVersion TLSv1 =
    TLSProperties_TLSVersion_TLSv1;
  static const TLSVersion TLSv1_1 =
    TLSProperties_TLSVersion_TLSv1_1;
  static const TLSVersion TLSv1_2 =
    TLSProperties_TLSVersion_TLSv1_2;
  static const TLSVersion TLSv1_3 =
    TLSProperties_TLSVersion_TLSv1_3;
  static inline bool TLSVersion_IsValid(int value) {
    return TLSProperties_TLSVersion_IsValid(value);
  }
  static const TLSVersion TLSVersion_MIN =
    TLSProperties_TLSVersion_TLSVersion_MIN;
  static const TLSVersion TLSVersion_MAX =
    TLSProperties_TLSVersion_TLSVersion_MAX;
  static const int TLSVersion_ARRAYSIZE =
    TLSProperties_TLSVersion_TLSVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TLSVersion_descriptor() {
    return TLSProperties_TLSVersion_descriptor();
  }
  static inline const ::std::string& TLSVersion_Name(TLSVersion value) {
    return TLSProperties_TLSVersion_Name(value);
  }
  static inline bool TLSVersion_Parse(const ::std::string& name,
      TLSVersion* value) {
    return TLSProperties_TLSVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string tls_sni_hostname = 3;
  void clear_tls_sni_hostname();
  static const int kTlsSniHostnameFieldNumber = 3;
  const ::std::string& tls_sni_hostname() const;
  void set_tls_sni_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_tls_sni_hostname(::std::string&& value);
  #endif
  void set_tls_sni_hostname(const char* value);
  void set_tls_sni_hostname(const char* value, size_t size);
  ::std::string* mutable_tls_sni_hostname();
  ::std::string* release_tls_sni_hostname();
  void set_allocated_tls_sni_hostname(::std::string* tls_sni_hostname);

  // .google.protobuf.UInt32Value tls_cipher_suite = 2;
  bool has_tls_cipher_suite() const;
  void clear_tls_cipher_suite();
  static const int kTlsCipherSuiteFieldNumber = 2;
  const ::google::protobuf::UInt32Value& tls_cipher_suite() const;
  ::google::protobuf::UInt32Value* release_tls_cipher_suite();
  ::google::protobuf::UInt32Value* mutable_tls_cipher_suite();
  void set_allocated_tls_cipher_suite(::google::protobuf::UInt32Value* tls_cipher_suite);

  // .envoy.api.v2.filter.accesslog.TLSProperties.TLSVersion tls_version = 1;
  void clear_tls_version();
  static const int kTlsVersionFieldNumber = 1;
  ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion tls_version() const;
  void set_tls_version(::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.TLSProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tls_sni_hostname_;
  ::google::protobuf::UInt32Value* tls_cipher_suite_;
  int tls_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsTLSPropertiesImpl();
};
// -------------------------------------------------------------------

class TCPAccessLogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.TCPAccessLogEntry) */ {
 public:
  TCPAccessLogEntry();
  virtual ~TCPAccessLogEntry();

  TCPAccessLogEntry(const TCPAccessLogEntry& from);

  inline TCPAccessLogEntry& operator=(const TCPAccessLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TCPAccessLogEntry(TCPAccessLogEntry&& from) noexcept
    : TCPAccessLogEntry() {
    *this = ::std::move(from);
  }

  inline TCPAccessLogEntry& operator=(TCPAccessLogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TCPAccessLogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TCPAccessLogEntry* internal_default_instance() {
    return reinterpret_cast<const TCPAccessLogEntry*>(
               &_TCPAccessLogEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TCPAccessLogEntry* other);
  friend void swap(TCPAccessLogEntry& a, TCPAccessLogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TCPAccessLogEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  TCPAccessLogEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TCPAccessLogEntry& from);
  void MergeFrom(const TCPAccessLogEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TCPAccessLogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.AccessLogCommon common_properties = 1;
  bool has_common_properties() const;
  void clear_common_properties();
  static const int kCommonPropertiesFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::AccessLogCommon& common_properties() const;
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* release_common_properties();
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* mutable_common_properties();
  void set_allocated_common_properties(::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.TCPAccessLogEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsTCPAccessLogEntryImpl();
};
// -------------------------------------------------------------------

class HTTPRequestProperties_RequestHeadersEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HTTPRequestProperties_RequestHeadersEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<HTTPRequestProperties_RequestHeadersEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HTTPRequestProperties_RequestHeadersEntry_DoNotUse();
  HTTPRequestProperties_RequestHeadersEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HTTPRequestProperties_RequestHeadersEntry_DoNotUse& other);
  static const HTTPRequestProperties_RequestHeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HTTPRequestProperties_RequestHeadersEntry_DoNotUse*>(&_HTTPRequestProperties_RequestHeadersEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HTTPRequestProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.HTTPRequestProperties) */ {
 public:
  HTTPRequestProperties();
  virtual ~HTTPRequestProperties();

  HTTPRequestProperties(const HTTPRequestProperties& from);

  inline HTTPRequestProperties& operator=(const HTTPRequestProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPRequestProperties(HTTPRequestProperties&& from) noexcept
    : HTTPRequestProperties() {
    *this = ::std::move(from);
  }

  inline HTTPRequestProperties& operator=(HTTPRequestProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPRequestProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPRequestProperties* internal_default_instance() {
    return reinterpret_cast<const HTTPRequestProperties*>(
               &_HTTPRequestProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HTTPRequestProperties* other);
  friend void swap(HTTPRequestProperties& a, HTTPRequestProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPRequestProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPRequestProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPRequestProperties& from);
  void MergeFrom(const HTTPRequestProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPRequestProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> request_headers = 13;
  int request_headers_size() const;
  void clear_request_headers();
  static const int kRequestHeadersFieldNumber = 13;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      request_headers() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_request_headers();

  // string scheme = 2;
  void clear_scheme();
  static const int kSchemeFieldNumber = 2;
  const ::std::string& scheme() const;
  void set_scheme(const ::std::string& value);
  #if LANG_CXX11
  void set_scheme(::std::string&& value);
  #endif
  void set_scheme(const char* value);
  void set_scheme(const char* value, size_t size);
  ::std::string* mutable_scheme();
  ::std::string* release_scheme();
  void set_allocated_scheme(::std::string* scheme);

  // string authority = 3;
  void clear_authority();
  static const int kAuthorityFieldNumber = 3;
  const ::std::string& authority() const;
  void set_authority(const ::std::string& value);
  #if LANG_CXX11
  void set_authority(::std::string&& value);
  #endif
  void set_authority(const char* value);
  void set_authority(const char* value, size_t size);
  ::std::string* mutable_authority();
  ::std::string* release_authority();
  void set_allocated_authority(::std::string* authority);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string user_agent = 6;
  void clear_user_agent();
  static const int kUserAgentFieldNumber = 6;
  const ::std::string& user_agent() const;
  void set_user_agent(const ::std::string& value);
  #if LANG_CXX11
  void set_user_agent(::std::string&& value);
  #endif
  void set_user_agent(const char* value);
  void set_user_agent(const char* value, size_t size);
  ::std::string* mutable_user_agent();
  ::std::string* release_user_agent();
  void set_allocated_user_agent(::std::string* user_agent);

  // string referer = 7;
  void clear_referer();
  static const int kRefererFieldNumber = 7;
  const ::std::string& referer() const;
  void set_referer(const ::std::string& value);
  #if LANG_CXX11
  void set_referer(::std::string&& value);
  #endif
  void set_referer(const char* value);
  void set_referer(const char* value, size_t size);
  ::std::string* mutable_referer();
  ::std::string* release_referer();
  void set_allocated_referer(::std::string* referer);

  // string forwarded_for = 8;
  void clear_forwarded_for();
  static const int kForwardedForFieldNumber = 8;
  const ::std::string& forwarded_for() const;
  void set_forwarded_for(const ::std::string& value);
  #if LANG_CXX11
  void set_forwarded_for(::std::string&& value);
  #endif
  void set_forwarded_for(const char* value);
  void set_forwarded_for(const char* value, size_t size);
  ::std::string* mutable_forwarded_for();
  ::std::string* release_forwarded_for();
  void set_allocated_forwarded_for(::std::string* forwarded_for);

  // string request_id = 9;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 9;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // string original_path = 10;
  void clear_original_path();
  static const int kOriginalPathFieldNumber = 10;
  const ::std::string& original_path() const;
  void set_original_path(const ::std::string& value);
  #if LANG_CXX11
  void set_original_path(::std::string&& value);
  #endif
  void set_original_path(const char* value);
  void set_original_path(const char* value, size_t size);
  ::std::string* mutable_original_path();
  ::std::string* release_original_path();
  void set_allocated_original_path(::std::string* original_path);

  // .google.protobuf.UInt32Value port = 4;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::google::protobuf::UInt32Value& port() const;
  ::google::protobuf::UInt32Value* release_port();
  ::google::protobuf::UInt32Value* mutable_port();
  void set_allocated_port(::google::protobuf::UInt32Value* port);

  // uint64 request_headers_bytes = 11;
  void clear_request_headers_bytes();
  static const int kRequestHeadersBytesFieldNumber = 11;
  ::google::protobuf::uint64 request_headers_bytes() const;
  void set_request_headers_bytes(::google::protobuf::uint64 value);

  // uint64 request_body_bytes = 12;
  void clear_request_body_bytes();
  static const int kRequestBodyBytesFieldNumber = 12;
  ::google::protobuf::uint64 request_body_bytes() const;
  void set_request_body_bytes(::google::protobuf::uint64 value);

  // .envoy.api.v2.RequestMethod request_method = 1;
  void clear_request_method();
  static const int kRequestMethodFieldNumber = 1;
  ::envoy::api::v2::RequestMethod request_method() const;
  void set_request_method(::envoy::api::v2::RequestMethod value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.HTTPRequestProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HTTPRequestProperties_RequestHeadersEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > request_headers_;
  ::google::protobuf::internal::ArenaStringPtr scheme_;
  ::google::protobuf::internal::ArenaStringPtr authority_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr user_agent_;
  ::google::protobuf::internal::ArenaStringPtr referer_;
  ::google::protobuf::internal::ArenaStringPtr forwarded_for_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  ::google::protobuf::internal::ArenaStringPtr original_path_;
  ::google::protobuf::UInt32Value* port_;
  ::google::protobuf::uint64 request_headers_bytes_;
  ::google::protobuf::uint64 request_body_bytes_;
  int request_method_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsHTTPRequestPropertiesImpl();
};
// -------------------------------------------------------------------

class HTTPResponseProperties_ResponseHeadersEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HTTPResponseProperties_ResponseHeadersEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<HTTPResponseProperties_ResponseHeadersEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HTTPResponseProperties_ResponseHeadersEntry_DoNotUse();
  HTTPResponseProperties_ResponseHeadersEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HTTPResponseProperties_ResponseHeadersEntry_DoNotUse& other);
  static const HTTPResponseProperties_ResponseHeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HTTPResponseProperties_ResponseHeadersEntry_DoNotUse*>(&_HTTPResponseProperties_ResponseHeadersEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HTTPResponseProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.HTTPResponseProperties) */ {
 public:
  HTTPResponseProperties();
  virtual ~HTTPResponseProperties();

  HTTPResponseProperties(const HTTPResponseProperties& from);

  inline HTTPResponseProperties& operator=(const HTTPResponseProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPResponseProperties(HTTPResponseProperties&& from) noexcept
    : HTTPResponseProperties() {
    *this = ::std::move(from);
  }

  inline HTTPResponseProperties& operator=(HTTPResponseProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPResponseProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPResponseProperties* internal_default_instance() {
    return reinterpret_cast<const HTTPResponseProperties*>(
               &_HTTPResponseProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(HTTPResponseProperties* other);
  friend void swap(HTTPResponseProperties& a, HTTPResponseProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPResponseProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPResponseProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPResponseProperties& from);
  void MergeFrom(const HTTPResponseProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPResponseProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> response_headers = 4;
  int response_headers_size() const;
  void clear_response_headers();
  static const int kResponseHeadersFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      response_headers() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_response_headers();

  // .google.protobuf.UInt32Value response_code = 1;
  bool has_response_code() const;
  void clear_response_code();
  static const int kResponseCodeFieldNumber = 1;
  const ::google::protobuf::UInt32Value& response_code() const;
  ::google::protobuf::UInt32Value* release_response_code();
  ::google::protobuf::UInt32Value* mutable_response_code();
  void set_allocated_response_code(::google::protobuf::UInt32Value* response_code);

  // uint64 response_headers_bytes = 2;
  void clear_response_headers_bytes();
  static const int kResponseHeadersBytesFieldNumber = 2;
  ::google::protobuf::uint64 response_headers_bytes() const;
  void set_response_headers_bytes(::google::protobuf::uint64 value);

  // uint64 response_body_bytes = 3;
  void clear_response_body_bytes();
  static const int kResponseBodyBytesFieldNumber = 3;
  ::google::protobuf::uint64 response_body_bytes() const;
  void set_response_body_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.HTTPResponseProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HTTPResponseProperties_ResponseHeadersEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > response_headers_;
  ::google::protobuf::UInt32Value* response_code_;
  ::google::protobuf::uint64 response_headers_bytes_;
  ::google::protobuf::uint64 response_body_bytes_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsHTTPResponsePropertiesImpl();
};
// -------------------------------------------------------------------

class HTTPAccessLogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry) */ {
 public:
  HTTPAccessLogEntry();
  virtual ~HTTPAccessLogEntry();

  HTTPAccessLogEntry(const HTTPAccessLogEntry& from);

  inline HTTPAccessLogEntry& operator=(const HTTPAccessLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPAccessLogEntry(HTTPAccessLogEntry&& from) noexcept
    : HTTPAccessLogEntry() {
    *this = ::std::move(from);
  }

  inline HTTPAccessLogEntry& operator=(HTTPAccessLogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPAccessLogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPAccessLogEntry* internal_default_instance() {
    return reinterpret_cast<const HTTPAccessLogEntry*>(
               &_HTTPAccessLogEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(HTTPAccessLogEntry* other);
  friend void swap(HTTPAccessLogEntry& a, HTTPAccessLogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPAccessLogEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPAccessLogEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPAccessLogEntry& from);
  void MergeFrom(const HTTPAccessLogEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPAccessLogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HTTPAccessLogEntry_HTTPVersion HTTPVersion;
  static const HTTPVersion PROTOCOL_UNSPECIFIED =
    HTTPAccessLogEntry_HTTPVersion_PROTOCOL_UNSPECIFIED;
  static const HTTPVersion HTTP10 =
    HTTPAccessLogEntry_HTTPVersion_HTTP10;
  static const HTTPVersion HTTP11 =
    HTTPAccessLogEntry_HTTPVersion_HTTP11;
  static const HTTPVersion HTTP2 =
    HTTPAccessLogEntry_HTTPVersion_HTTP2;
  static inline bool HTTPVersion_IsValid(int value) {
    return HTTPAccessLogEntry_HTTPVersion_IsValid(value);
  }
  static const HTTPVersion HTTPVersion_MIN =
    HTTPAccessLogEntry_HTTPVersion_HTTPVersion_MIN;
  static const HTTPVersion HTTPVersion_MAX =
    HTTPAccessLogEntry_HTTPVersion_HTTPVersion_MAX;
  static const int HTTPVersion_ARRAYSIZE =
    HTTPAccessLogEntry_HTTPVersion_HTTPVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HTTPVersion_descriptor() {
    return HTTPAccessLogEntry_HTTPVersion_descriptor();
  }
  static inline const ::std::string& HTTPVersion_Name(HTTPVersion value) {
    return HTTPAccessLogEntry_HTTPVersion_Name(value);
  }
  static inline bool HTTPVersion_Parse(const ::std::string& name,
      HTTPVersion* value) {
    return HTTPAccessLogEntry_HTTPVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.AccessLogCommon common_properties = 1;
  bool has_common_properties() const;
  void clear_common_properties();
  static const int kCommonPropertiesFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::AccessLogCommon& common_properties() const;
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* release_common_properties();
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* mutable_common_properties();
  void set_allocated_common_properties(::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties);

  // .envoy.api.v2.filter.accesslog.HTTPRequestProperties request = 3;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 3;
  const ::envoy::api::v2::filter::accesslog::HTTPRequestProperties& request() const;
  ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* release_request();
  ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* mutable_request();
  void set_allocated_request(::envoy::api::v2::filter::accesslog::HTTPRequestProperties* request);

  // .envoy.api.v2.filter.accesslog.HTTPResponseProperties response = 4;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 4;
  const ::envoy::api::v2::filter::accesslog::HTTPResponseProperties& response() const;
  ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* release_response();
  ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* mutable_response();
  void set_allocated_response(::envoy::api::v2::filter::accesslog::HTTPResponseProperties* response);

  // .envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.HTTPVersion protocol_version = 2;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 2;
  ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion protocol_version() const;
  void set_protocol_version(::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties_;
  ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* request_;
  ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* response_;
  int protocol_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsHTTPAccessLogEntryImpl();
};
// -------------------------------------------------------------------

class ComparisonFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.ComparisonFilter) */ {
 public:
  ComparisonFilter();
  virtual ~ComparisonFilter();

  ComparisonFilter(const ComparisonFilter& from);

  inline ComparisonFilter& operator=(const ComparisonFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComparisonFilter(ComparisonFilter&& from) noexcept
    : ComparisonFilter() {
    *this = ::std::move(from);
  }

  inline ComparisonFilter& operator=(ComparisonFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ComparisonFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComparisonFilter* internal_default_instance() {
    return reinterpret_cast<const ComparisonFilter*>(
               &_ComparisonFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ComparisonFilter* other);
  friend void swap(ComparisonFilter& a, ComparisonFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComparisonFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  ComparisonFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ComparisonFilter& from);
  void MergeFrom(const ComparisonFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ComparisonFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ComparisonFilter_Op Op;
  static const Op EQ =
    ComparisonFilter_Op_EQ;
  static const Op GE =
    ComparisonFilter_Op_GE;
  static inline bool Op_IsValid(int value) {
    return ComparisonFilter_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ComparisonFilter_Op_Op_MIN;
  static const Op Op_MAX =
    ComparisonFilter_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ComparisonFilter_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ComparisonFilter_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ComparisonFilter_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ComparisonFilter_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .envoy.api.v2.RuntimeUInt32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::envoy::api::v2::RuntimeUInt32& value() const;
  ::envoy::api::v2::RuntimeUInt32* release_value();
  ::envoy::api::v2::RuntimeUInt32* mutable_value();
  void set_allocated_value(::envoy::api::v2::RuntimeUInt32* value);

  // .envoy.api.v2.filter.accesslog.ComparisonFilter.Op op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op op() const;
  void set_op(::envoy::api::v2::filter::accesslog::ComparisonFilter_Op value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.ComparisonFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::RuntimeUInt32* value_;
  int op_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsComparisonFilterImpl();
};
// -------------------------------------------------------------------

class StatusCodeFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StatusCodeFilter) */ {
 public:
  StatusCodeFilter();
  virtual ~StatusCodeFilter();

  StatusCodeFilter(const StatusCodeFilter& from);

  inline StatusCodeFilter& operator=(const StatusCodeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusCodeFilter(StatusCodeFilter&& from) noexcept
    : StatusCodeFilter() {
    *this = ::std::move(from);
  }

  inline StatusCodeFilter& operator=(StatusCodeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusCodeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusCodeFilter* internal_default_instance() {
    return reinterpret_cast<const StatusCodeFilter*>(
               &_StatusCodeFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(StatusCodeFilter* other);
  friend void swap(StatusCodeFilter& a, StatusCodeFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusCodeFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusCodeFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusCodeFilter& from);
  void MergeFrom(const StatusCodeFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusCodeFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.ComparisonFilter comparison = 1;
  bool has_comparison() const;
  void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::ComparisonFilter& comparison() const;
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* release_comparison();
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* mutable_comparison();
  void set_allocated_comparison(::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StatusCodeFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStatusCodeFilterImpl();
};
// -------------------------------------------------------------------

class DurationFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.DurationFilter) */ {
 public:
  DurationFilter();
  virtual ~DurationFilter();

  DurationFilter(const DurationFilter& from);

  inline DurationFilter& operator=(const DurationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DurationFilter(DurationFilter&& from) noexcept
    : DurationFilter() {
    *this = ::std::move(from);
  }

  inline DurationFilter& operator=(DurationFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DurationFilter* internal_default_instance() {
    return reinterpret_cast<const DurationFilter*>(
               &_DurationFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DurationFilter* other);
  friend void swap(DurationFilter& a, DurationFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DurationFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  DurationFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DurationFilter& from);
  void MergeFrom(const DurationFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DurationFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.ComparisonFilter comparison = 1;
  bool has_comparison() const;
  void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::ComparisonFilter& comparison() const;
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* release_comparison();
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* mutable_comparison();
  void set_allocated_comparison(::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.DurationFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsDurationFilterImpl();
};
// -------------------------------------------------------------------

class NotHealthCheckFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.NotHealthCheckFilter) */ {
 public:
  NotHealthCheckFilter();
  virtual ~NotHealthCheckFilter();

  NotHealthCheckFilter(const NotHealthCheckFilter& from);

  inline NotHealthCheckFilter& operator=(const NotHealthCheckFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotHealthCheckFilter(NotHealthCheckFilter&& from) noexcept
    : NotHealthCheckFilter() {
    *this = ::std::move(from);
  }

  inline NotHealthCheckFilter& operator=(NotHealthCheckFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotHealthCheckFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotHealthCheckFilter* internal_default_instance() {
    return reinterpret_cast<const NotHealthCheckFilter*>(
               &_NotHealthCheckFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(NotHealthCheckFilter* other);
  friend void swap(NotHealthCheckFilter& a, NotHealthCheckFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotHealthCheckFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  NotHealthCheckFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NotHealthCheckFilter& from);
  void MergeFrom(const NotHealthCheckFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NotHealthCheckFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.NotHealthCheckFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsNotHealthCheckFilterImpl();
};
// -------------------------------------------------------------------

class TraceableFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.TraceableFilter) */ {
 public:
  TraceableFilter();
  virtual ~TraceableFilter();

  TraceableFilter(const TraceableFilter& from);

  inline TraceableFilter& operator=(const TraceableFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TraceableFilter(TraceableFilter&& from) noexcept
    : TraceableFilter() {
    *this = ::std::move(from);
  }

  inline TraceableFilter& operator=(TraceableFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceableFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TraceableFilter* internal_default_instance() {
    return reinterpret_cast<const TraceableFilter*>(
               &_TraceableFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TraceableFilter* other);
  friend void swap(TraceableFilter& a, TraceableFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TraceableFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  TraceableFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TraceableFilter& from);
  void MergeFrom(const TraceableFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TraceableFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.TraceableFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsTraceableFilterImpl();
};
// -------------------------------------------------------------------

class RuntimeFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.RuntimeFilter) */ {
 public:
  RuntimeFilter();
  virtual ~RuntimeFilter();

  RuntimeFilter(const RuntimeFilter& from);

  inline RuntimeFilter& operator=(const RuntimeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeFilter(RuntimeFilter&& from) noexcept
    : RuntimeFilter() {
    *this = ::std::move(from);
  }

  inline RuntimeFilter& operator=(RuntimeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeFilter* internal_default_instance() {
    return reinterpret_cast<const RuntimeFilter*>(
               &_RuntimeFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RuntimeFilter* other);
  friend void swap(RuntimeFilter& a, RuntimeFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeFilter& from);
  void MergeFrom(const RuntimeFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string runtime_key = 1;
  void clear_runtime_key();
  static const int kRuntimeKeyFieldNumber = 1;
  const ::std::string& runtime_key() const;
  void set_runtime_key(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_key(::std::string&& value);
  #endif
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  ::std::string* mutable_runtime_key();
  ::std::string* release_runtime_key();
  void set_allocated_runtime_key(::std::string* runtime_key);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.RuntimeFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr runtime_key_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsRuntimeFilterImpl();
};
// -------------------------------------------------------------------

class AndFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.AndFilter) */ {
 public:
  AndFilter();
  virtual ~AndFilter();

  AndFilter(const AndFilter& from);

  inline AndFilter& operator=(const AndFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AndFilter(AndFilter&& from) noexcept
    : AndFilter() {
    *this = ::std::move(from);
  }

  inline AndFilter& operator=(AndFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AndFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AndFilter* internal_default_instance() {
    return reinterpret_cast<const AndFilter*>(
               &_AndFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AndFilter* other);
  friend void swap(AndFilter& a, AndFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AndFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  AndFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndFilter& from);
  void MergeFrom(const AndFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.accesslog.AccessLogFilter filters = 1;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::AccessLogFilter& filters(int index) const;
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* mutable_filters(int index);
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.AndFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter > filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class OrFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.OrFilter) */ {
 public:
  OrFilter();
  virtual ~OrFilter();

  OrFilter(const OrFilter& from);

  inline OrFilter& operator=(const OrFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrFilter(OrFilter&& from) noexcept
    : OrFilter() {
    *this = ::std::move(from);
  }

  inline OrFilter& operator=(OrFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrFilter* internal_default_instance() {
    return reinterpret_cast<const OrFilter*>(
               &_OrFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(OrFilter* other);
  friend void swap(OrFilter& a, OrFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  OrFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OrFilter& from);
  void MergeFrom(const OrFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OrFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.accesslog.AccessLogFilter filters = 2;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  const ::envoy::api::v2::filter::accesslog::AccessLogFilter& filters(int index) const;
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* mutable_filters(int index);
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.OrFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter > filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class AccessLogFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.AccessLogFilter) */ {
 public:
  AccessLogFilter();
  virtual ~AccessLogFilter();

  AccessLogFilter(const AccessLogFilter& from);

  inline AccessLogFilter& operator=(const AccessLogFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLogFilter(AccessLogFilter&& from) noexcept
    : AccessLogFilter() {
    *this = ::std::move(from);
  }

  inline AccessLogFilter& operator=(AccessLogFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLogFilter& default_instance();

  enum FilterSpecifierCase {
    kStatusCodeFilter = 1,
    kDurationFilter = 2,
    kNotHealthCheckFilter = 3,
    kTraceableFilter = 4,
    kRuntimeFilter = 5,
    kAndFilter = 6,
    kOrFilter = 7,
    FILTER_SPECIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLogFilter* internal_default_instance() {
    return reinterpret_cast<const AccessLogFilter*>(
               &_AccessLogFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(AccessLogFilter* other);
  friend void swap(AccessLogFilter& a, AccessLogFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLogFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLogFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLogFilter& from);
  void MergeFrom(const AccessLogFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLogFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.StatusCodeFilter status_code_filter = 1;
  bool has_status_code_filter() const;
  void clear_status_code_filter();
  static const int kStatusCodeFilterFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::StatusCodeFilter& status_code_filter() const;
  ::envoy::api::v2::filter::accesslog::StatusCodeFilter* release_status_code_filter();
  ::envoy::api::v2::filter::accesslog::StatusCodeFilter* mutable_status_code_filter();
  void set_allocated_status_code_filter(::envoy::api::v2::filter::accesslog::StatusCodeFilter* status_code_filter);

  // .envoy.api.v2.filter.accesslog.DurationFilter duration_filter = 2;
  bool has_duration_filter() const;
  void clear_duration_filter();
  static const int kDurationFilterFieldNumber = 2;
  const ::envoy::api::v2::filter::accesslog::DurationFilter& duration_filter() const;
  ::envoy::api::v2::filter::accesslog::DurationFilter* release_duration_filter();
  ::envoy::api::v2::filter::accesslog::DurationFilter* mutable_duration_filter();
  void set_allocated_duration_filter(::envoy::api::v2::filter::accesslog::DurationFilter* duration_filter);

  // .envoy.api.v2.filter.accesslog.NotHealthCheckFilter not_health_check_filter = 3;
  bool has_not_health_check_filter() const;
  void clear_not_health_check_filter();
  static const int kNotHealthCheckFilterFieldNumber = 3;
  const ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter& not_health_check_filter() const;
  ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* release_not_health_check_filter();
  ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* mutable_not_health_check_filter();
  void set_allocated_not_health_check_filter(::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* not_health_check_filter);

  // .envoy.api.v2.filter.accesslog.TraceableFilter traceable_filter = 4;
  bool has_traceable_filter() const;
  void clear_traceable_filter();
  static const int kTraceableFilterFieldNumber = 4;
  const ::envoy::api::v2::filter::accesslog::TraceableFilter& traceable_filter() const;
  ::envoy::api::v2::filter::accesslog::TraceableFilter* release_traceable_filter();
  ::envoy::api::v2::filter::accesslog::TraceableFilter* mutable_traceable_filter();
  void set_allocated_traceable_filter(::envoy::api::v2::filter::accesslog::TraceableFilter* traceable_filter);

  // .envoy.api.v2.filter.accesslog.RuntimeFilter runtime_filter = 5;
  bool has_runtime_filter() const;
  void clear_runtime_filter();
  static const int kRuntimeFilterFieldNumber = 5;
  const ::envoy::api::v2::filter::accesslog::RuntimeFilter& runtime_filter() const;
  ::envoy::api::v2::filter::accesslog::RuntimeFilter* release_runtime_filter();
  ::envoy::api::v2::filter::accesslog::RuntimeFilter* mutable_runtime_filter();
  void set_allocated_runtime_filter(::envoy::api::v2::filter::accesslog::RuntimeFilter* runtime_filter);

  // .envoy.api.v2.filter.accesslog.AndFilter and_filter = 6;
  bool has_and_filter() const;
  void clear_and_filter();
  static const int kAndFilterFieldNumber = 6;
  const ::envoy::api::v2::filter::accesslog::AndFilter& and_filter() const;
  ::envoy::api::v2::filter::accesslog::AndFilter* release_and_filter();
  ::envoy::api::v2::filter::accesslog::AndFilter* mutable_and_filter();
  void set_allocated_and_filter(::envoy::api::v2::filter::accesslog::AndFilter* and_filter);

  // .envoy.api.v2.filter.accesslog.OrFilter or_filter = 7;
  bool has_or_filter() const;
  void clear_or_filter();
  static const int kOrFilterFieldNumber = 7;
  const ::envoy::api::v2::filter::accesslog::OrFilter& or_filter() const;
  ::envoy::api::v2::filter::accesslog::OrFilter* release_or_filter();
  ::envoy::api::v2::filter::accesslog::OrFilter* mutable_or_filter();
  void set_allocated_or_filter(::envoy::api::v2::filter::accesslog::OrFilter* or_filter);

  FilterSpecifierCase filter_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.AccessLogFilter)
 private:
  void set_has_status_code_filter();
  void set_has_duration_filter();
  void set_has_not_health_check_filter();
  void set_has_traceable_filter();
  void set_has_runtime_filter();
  void set_has_and_filter();
  void set_has_or_filter();

  inline bool has_filter_specifier() const;
  void clear_filter_specifier();
  inline void clear_has_filter_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union FilterSpecifierUnion {
    FilterSpecifierUnion() {}
    ::envoy::api::v2::filter::accesslog::StatusCodeFilter* status_code_filter_;
    ::envoy::api::v2::filter::accesslog::DurationFilter* duration_filter_;
    ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* not_health_check_filter_;
    ::envoy::api::v2::filter::accesslog::TraceableFilter* traceable_filter_;
    ::envoy::api::v2::filter::accesslog::RuntimeFilter* runtime_filter_;
    ::envoy::api::v2::filter::accesslog::AndFilter* and_filter_;
    ::envoy::api::v2::filter::accesslog::OrFilter* or_filter_;
  } filter_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class FileAccessLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.FileAccessLog) */ {
 public:
  FileAccessLog();
  virtual ~FileAccessLog();

  FileAccessLog(const FileAccessLog& from);

  inline FileAccessLog& operator=(const FileAccessLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileAccessLog(FileAccessLog&& from) noexcept
    : FileAccessLog() {
    *this = ::std::move(from);
  }

  inline FileAccessLog& operator=(FileAccessLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileAccessLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileAccessLog* internal_default_instance() {
    return reinterpret_cast<const FileAccessLog*>(
               &_FileAccessLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(FileAccessLog* other);
  friend void swap(FileAccessLog& a, FileAccessLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileAccessLog* New() const PROTOBUF_FINAL { return New(NULL); }

  FileAccessLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileAccessLog& from);
  void MergeFrom(const FileAccessLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileAccessLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.FileAccessLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsFileAccessLogImpl();
};
// -------------------------------------------------------------------

class AccessLogServiceConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.AccessLogServiceConfig) */ {
 public:
  AccessLogServiceConfig();
  virtual ~AccessLogServiceConfig();

  AccessLogServiceConfig(const AccessLogServiceConfig& from);

  inline AccessLogServiceConfig& operator=(const AccessLogServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLogServiceConfig(AccessLogServiceConfig&& from) noexcept
    : AccessLogServiceConfig() {
    *this = ::std::move(from);
  }

  inline AccessLogServiceConfig& operator=(AccessLogServiceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLogServiceConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLogServiceConfig* internal_default_instance() {
    return reinterpret_cast<const AccessLogServiceConfig*>(
               &_AccessLogServiceConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(AccessLogServiceConfig* other);
  friend void swap(AccessLogServiceConfig& a, AccessLogServiceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLogServiceConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLogServiceConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLogServiceConfig& from);
  void MergeFrom(const AccessLogServiceConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLogServiceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log_name = 1;
  void clear_log_name();
  static const int kLogNameFieldNumber = 1;
  const ::std::string& log_name() const;
  void set_log_name(const ::std::string& value);
  #if LANG_CXX11
  void set_log_name(::std::string&& value);
  #endif
  void set_log_name(const char* value);
  void set_log_name(const char* value, size_t size);
  ::std::string* mutable_log_name();
  ::std::string* release_log_name();
  void set_allocated_log_name(::std::string* log_name);

  // string cluster_name = 2;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 2;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.AccessLogServiceConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_name_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogServiceConfigImpl();
};
// -------------------------------------------------------------------

class StreamAccessLogsMessage_Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier) */ {
 public:
  StreamAccessLogsMessage_Identifier();
  virtual ~StreamAccessLogsMessage_Identifier();

  StreamAccessLogsMessage_Identifier(const StreamAccessLogsMessage_Identifier& from);

  inline StreamAccessLogsMessage_Identifier& operator=(const StreamAccessLogsMessage_Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAccessLogsMessage_Identifier(StreamAccessLogsMessage_Identifier&& from) noexcept
    : StreamAccessLogsMessage_Identifier() {
    *this = ::std::move(from);
  }

  inline StreamAccessLogsMessage_Identifier& operator=(StreamAccessLogsMessage_Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamAccessLogsMessage_Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAccessLogsMessage_Identifier* internal_default_instance() {
    return reinterpret_cast<const StreamAccessLogsMessage_Identifier*>(
               &_StreamAccessLogsMessage_Identifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(StreamAccessLogsMessage_Identifier* other);
  friend void swap(StreamAccessLogsMessage_Identifier& a, StreamAccessLogsMessage_Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAccessLogsMessage_Identifier* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAccessLogsMessage_Identifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamAccessLogsMessage_Identifier& from);
  void MergeFrom(const StreamAccessLogsMessage_Identifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamAccessLogsMessage_Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log_name = 2;
  void clear_log_name();
  static const int kLogNameFieldNumber = 2;
  const ::std::string& log_name() const;
  void set_log_name(const ::std::string& value);
  #if LANG_CXX11
  void set_log_name(::std::string&& value);
  #endif
  void set_log_name(const char* value);
  void set_log_name(const char* value, size_t size);
  ::std::string* mutable_log_name();
  ::std::string* release_log_name();
  void set_allocated_log_name(::std::string* log_name);

  // .envoy.api.v2.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::envoy::api::v2::Node& node() const;
  ::envoy::api::v2::Node* release_node();
  ::envoy::api::v2::Node* mutable_node();
  void set_allocated_node(::envoy::api::v2::Node* node);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_name_;
  ::envoy::api::v2::Node* node_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStreamAccessLogsMessage_IdentifierImpl();
};
// -------------------------------------------------------------------

class StreamAccessLogsMessage_HTTPAccessLogEntries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries) */ {
 public:
  StreamAccessLogsMessage_HTTPAccessLogEntries();
  virtual ~StreamAccessLogsMessage_HTTPAccessLogEntries();

  StreamAccessLogsMessage_HTTPAccessLogEntries(const StreamAccessLogsMessage_HTTPAccessLogEntries& from);

  inline StreamAccessLogsMessage_HTTPAccessLogEntries& operator=(const StreamAccessLogsMessage_HTTPAccessLogEntries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAccessLogsMessage_HTTPAccessLogEntries(StreamAccessLogsMessage_HTTPAccessLogEntries&& from) noexcept
    : StreamAccessLogsMessage_HTTPAccessLogEntries() {
    *this = ::std::move(from);
  }

  inline StreamAccessLogsMessage_HTTPAccessLogEntries& operator=(StreamAccessLogsMessage_HTTPAccessLogEntries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamAccessLogsMessage_HTTPAccessLogEntries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAccessLogsMessage_HTTPAccessLogEntries* internal_default_instance() {
    return reinterpret_cast<const StreamAccessLogsMessage_HTTPAccessLogEntries*>(
               &_StreamAccessLogsMessage_HTTPAccessLogEntries_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(StreamAccessLogsMessage_HTTPAccessLogEntries* other);
  friend void swap(StreamAccessLogsMessage_HTTPAccessLogEntries& a, StreamAccessLogsMessage_HTTPAccessLogEntries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAccessLogsMessage_HTTPAccessLogEntries* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAccessLogsMessage_HTTPAccessLogEntries* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamAccessLogsMessage_HTTPAccessLogEntries& from);
  void MergeFrom(const StreamAccessLogsMessage_HTTPAccessLogEntries& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamAccessLogsMessage_HTTPAccessLogEntries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.accesslog.HTTPAccessLogEntry log_entry = 1;
  int log_entry_size() const;
  void clear_log_entry();
  static const int kLogEntryFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry& log_entry(int index) const;
  ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry* mutable_log_entry(int index);
  ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry* add_log_entry();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry >*
      mutable_log_entry();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry >&
      log_entry() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry > log_entry_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStreamAccessLogsMessage_HTTPAccessLogEntriesImpl();
};
// -------------------------------------------------------------------

class StreamAccessLogsMessage_TCPAccessLogEntries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries) */ {
 public:
  StreamAccessLogsMessage_TCPAccessLogEntries();
  virtual ~StreamAccessLogsMessage_TCPAccessLogEntries();

  StreamAccessLogsMessage_TCPAccessLogEntries(const StreamAccessLogsMessage_TCPAccessLogEntries& from);

  inline StreamAccessLogsMessage_TCPAccessLogEntries& operator=(const StreamAccessLogsMessage_TCPAccessLogEntries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAccessLogsMessage_TCPAccessLogEntries(StreamAccessLogsMessage_TCPAccessLogEntries&& from) noexcept
    : StreamAccessLogsMessage_TCPAccessLogEntries() {
    *this = ::std::move(from);
  }

  inline StreamAccessLogsMessage_TCPAccessLogEntries& operator=(StreamAccessLogsMessage_TCPAccessLogEntries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamAccessLogsMessage_TCPAccessLogEntries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAccessLogsMessage_TCPAccessLogEntries* internal_default_instance() {
    return reinterpret_cast<const StreamAccessLogsMessage_TCPAccessLogEntries*>(
               &_StreamAccessLogsMessage_TCPAccessLogEntries_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(StreamAccessLogsMessage_TCPAccessLogEntries* other);
  friend void swap(StreamAccessLogsMessage_TCPAccessLogEntries& a, StreamAccessLogsMessage_TCPAccessLogEntries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAccessLogsMessage_TCPAccessLogEntries* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAccessLogsMessage_TCPAccessLogEntries* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamAccessLogsMessage_TCPAccessLogEntries& from);
  void MergeFrom(const StreamAccessLogsMessage_TCPAccessLogEntries& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamAccessLogsMessage_TCPAccessLogEntries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.accesslog.TCPAccessLogEntry log_entry = 1;
  int log_entry_size() const;
  void clear_log_entry();
  static const int kLogEntryFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry& log_entry(int index) const;
  ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry* mutable_log_entry(int index);
  ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry* add_log_entry();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry >*
      mutable_log_entry();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry >&
      log_entry() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry > log_entry_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStreamAccessLogsMessage_TCPAccessLogEntriesImpl();
};
// -------------------------------------------------------------------

class StreamAccessLogsMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage) */ {
 public:
  StreamAccessLogsMessage();
  virtual ~StreamAccessLogsMessage();

  StreamAccessLogsMessage(const StreamAccessLogsMessage& from);

  inline StreamAccessLogsMessage& operator=(const StreamAccessLogsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAccessLogsMessage(StreamAccessLogsMessage&& from) noexcept
    : StreamAccessLogsMessage() {
    *this = ::std::move(from);
  }

  inline StreamAccessLogsMessage& operator=(StreamAccessLogsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamAccessLogsMessage& default_instance();

  enum LogEntriesCase {
    kHttpLogs = 2,
    kTcpLogs = 3,
    LOG_ENTRIES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAccessLogsMessage* internal_default_instance() {
    return reinterpret_cast<const StreamAccessLogsMessage*>(
               &_StreamAccessLogsMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(StreamAccessLogsMessage* other);
  friend void swap(StreamAccessLogsMessage& a, StreamAccessLogsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAccessLogsMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAccessLogsMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamAccessLogsMessage& from);
  void MergeFrom(const StreamAccessLogsMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamAccessLogsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef StreamAccessLogsMessage_Identifier Identifier;
  typedef StreamAccessLogsMessage_HTTPAccessLogEntries HTTPAccessLogEntries;
  typedef StreamAccessLogsMessage_TCPAccessLogEntries TCPAccessLogEntries;

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier& identifier() const;
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* release_identifier();
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* mutable_identifier();
  void set_allocated_identifier(::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* identifier);

  // .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries http_logs = 2;
  bool has_http_logs() const;
  void clear_http_logs();
  static const int kHttpLogsFieldNumber = 2;
  const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries& http_logs() const;
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* release_http_logs();
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* mutable_http_logs();
  void set_allocated_http_logs(::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* http_logs);

  // .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries tcp_logs = 3;
  bool has_tcp_logs() const;
  void clear_tcp_logs();
  static const int kTcpLogsFieldNumber = 3;
  const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries& tcp_logs() const;
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* release_tcp_logs();
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* mutable_tcp_logs();
  void set_allocated_tcp_logs(::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* tcp_logs);

  LogEntriesCase log_entries_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage)
 private:
  void set_has_http_logs();
  void set_has_tcp_logs();

  inline bool has_log_entries() const;
  void clear_log_entries();
  inline void clear_has_log_entries();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* identifier_;
  union LogEntriesUnion {
    LogEntriesUnion() {}
    ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* http_logs_;
    ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* tcp_logs_;
  } log_entries_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStreamAccessLogsMessageImpl();
};
// -------------------------------------------------------------------

class StreamAccessLogsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.StreamAccessLogsResponse) */ {
 public:
  StreamAccessLogsResponse();
  virtual ~StreamAccessLogsResponse();

  StreamAccessLogsResponse(const StreamAccessLogsResponse& from);

  inline StreamAccessLogsResponse& operator=(const StreamAccessLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAccessLogsResponse(StreamAccessLogsResponse&& from) noexcept
    : StreamAccessLogsResponse() {
    *this = ::std::move(from);
  }

  inline StreamAccessLogsResponse& operator=(StreamAccessLogsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamAccessLogsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAccessLogsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamAccessLogsResponse*>(
               &_StreamAccessLogsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(StreamAccessLogsResponse* other);
  friend void swap(StreamAccessLogsResponse& a, StreamAccessLogsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAccessLogsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAccessLogsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamAccessLogsResponse& from);
  void MergeFrom(const StreamAccessLogsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamAccessLogsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.StreamAccessLogsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsStreamAccessLogsResponseImpl();
};
// -------------------------------------------------------------------

class AccessLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.accesslog.AccessLog) */ {
 public:
  AccessLog();
  virtual ~AccessLog();

  AccessLog(const AccessLog& from);

  inline AccessLog& operator=(const AccessLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLog(AccessLog&& from) noexcept
    : AccessLog() {
    *this = ::std::move(from);
  }

  inline AccessLog& operator=(AccessLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLog* internal_default_instance() {
    return reinterpret_cast<const AccessLog*>(
               &_AccessLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(AccessLog* other);
  friend void swap(AccessLog& a, AccessLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLog* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLog& from);
  void MergeFrom(const AccessLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .envoy.api.v2.filter.accesslog.AccessLogFilter filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  const ::envoy::api::v2::filter::accesslog::AccessLogFilter& filter() const;
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* release_filter();
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* mutable_filter();
  void set_allocated_filter(::envoy::api::v2::filter::accesslog::AccessLogFilter* filter);

  // .google.protobuf.Struct config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::google::protobuf::Struct& config() const;
  ::google::protobuf::Struct* release_config();
  ::google::protobuf::Struct* mutable_config();
  void set_allocated_config(::google::protobuf::Struct* config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.accesslog.AccessLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* filter_;
  ::google::protobuf::Struct* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2faccesslog_2eproto::InitDefaultsAccessLogImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccessLogCommon

// double sample_rate = 1 [(.validate.rules) = {
inline void AccessLogCommon::clear_sample_rate() {
  sample_rate_ = 0;
}
inline double AccessLogCommon::sample_rate() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.sample_rate)
  return sample_rate_;
}
inline void AccessLogCommon::set_sample_rate(double value) {
  
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.AccessLogCommon.sample_rate)
}

// .envoy.api.v2.SocketAddress destination_host = 2;
inline bool AccessLogCommon::has_destination_host() const {
  return this != internal_default_instance() && destination_host_ != NULL;
}
inline const ::envoy::api::v2::SocketAddress& AccessLogCommon::destination_host() const {
  const ::envoy::api::v2::SocketAddress* p = destination_host_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.destination_host)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::SocketAddress*>(
      &::envoy::api::v2::_SocketAddress_default_instance_);
}
inline ::envoy::api::v2::SocketAddress* AccessLogCommon::release_destination_host() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.destination_host)
  
  ::envoy::api::v2::SocketAddress* temp = destination_host_;
  destination_host_ = NULL;
  return temp;
}
inline ::envoy::api::v2::SocketAddress* AccessLogCommon::mutable_destination_host() {
  
  if (destination_host_ == NULL) {
    destination_host_ = new ::envoy::api::v2::SocketAddress;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.destination_host)
  return destination_host_;
}
inline void AccessLogCommon::set_allocated_destination_host(::envoy::api::v2::SocketAddress* destination_host) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(destination_host_);
  }
  if (destination_host) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      destination_host = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination_host, submessage_arena);
    }
    
  } else {
    
  }
  destination_host_ = destination_host;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.destination_host)
}

// .envoy.api.v2.filter.accesslog.TLSProperties tls_properties = 3;
inline bool AccessLogCommon::has_tls_properties() const {
  return this != internal_default_instance() && tls_properties_ != NULL;
}
inline void AccessLogCommon::clear_tls_properties() {
  if (GetArenaNoVirtual() == NULL && tls_properties_ != NULL) {
    delete tls_properties_;
  }
  tls_properties_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::TLSProperties& AccessLogCommon::tls_properties() const {
  const ::envoy::api::v2::filter::accesslog::TLSProperties* p = tls_properties_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.tls_properties)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::TLSProperties*>(
      &::envoy::api::v2::filter::accesslog::_TLSProperties_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::TLSProperties* AccessLogCommon::release_tls_properties() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.tls_properties)
  
  ::envoy::api::v2::filter::accesslog::TLSProperties* temp = tls_properties_;
  tls_properties_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::TLSProperties* AccessLogCommon::mutable_tls_properties() {
  
  if (tls_properties_ == NULL) {
    tls_properties_ = new ::envoy::api::v2::filter::accesslog::TLSProperties;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.tls_properties)
  return tls_properties_;
}
inline void AccessLogCommon::set_allocated_tls_properties(::envoy::api::v2::filter::accesslog::TLSProperties* tls_properties) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_properties_;
  }
  if (tls_properties) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls_properties = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls_properties, submessage_arena);
    }
    
  } else {
    
  }
  tls_properties_ = tls_properties;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.tls_properties)
}

// .google.protobuf.Timestamp start_time = 4;
inline bool AccessLogCommon::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& AccessLogCommon::start_time() const {
  const ::google::protobuf::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* AccessLogCommon::release_start_time() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.start_time)
  
  ::google::protobuf::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* AccessLogCommon::mutable_start_time() {
  
  if (start_time_ == NULL) {
    start_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.start_time)
  return start_time_;
}
inline void AccessLogCommon::set_allocated_start_time(::google::protobuf::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.start_time)
}

// .google.protobuf.Duration time_to_last_rx_byte = 5;
inline bool AccessLogCommon::has_time_to_last_rx_byte() const {
  return this != internal_default_instance() && time_to_last_rx_byte_ != NULL;
}
inline const ::google::protobuf::Duration& AccessLogCommon::time_to_last_rx_byte() const {
  const ::google::protobuf::Duration* p = time_to_last_rx_byte_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_rx_byte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* AccessLogCommon::release_time_to_last_rx_byte() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_rx_byte)
  
  ::google::protobuf::Duration* temp = time_to_last_rx_byte_;
  time_to_last_rx_byte_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* AccessLogCommon::mutable_time_to_last_rx_byte() {
  
  if (time_to_last_rx_byte_ == NULL) {
    time_to_last_rx_byte_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_rx_byte)
  return time_to_last_rx_byte_;
}
inline void AccessLogCommon::set_allocated_time_to_last_rx_byte(::google::protobuf::Duration* time_to_last_rx_byte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_last_rx_byte_);
  }
  if (time_to_last_rx_byte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_last_rx_byte)->GetArena();
    if (message_arena != submessage_arena) {
      time_to_last_rx_byte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_to_last_rx_byte, submessage_arena);
    }
    
  } else {
    
  }
  time_to_last_rx_byte_ = time_to_last_rx_byte;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_rx_byte)
}

// .google.protobuf.Duration time_to_first_upstream_rx_byte = 6;
inline bool AccessLogCommon::has_time_to_first_upstream_rx_byte() const {
  return this != internal_default_instance() && time_to_first_upstream_rx_byte_ != NULL;
}
inline const ::google::protobuf::Duration& AccessLogCommon::time_to_first_upstream_rx_byte() const {
  const ::google::protobuf::Duration* p = time_to_first_upstream_rx_byte_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_first_upstream_rx_byte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* AccessLogCommon::release_time_to_first_upstream_rx_byte() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_first_upstream_rx_byte)
  
  ::google::protobuf::Duration* temp = time_to_first_upstream_rx_byte_;
  time_to_first_upstream_rx_byte_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* AccessLogCommon::mutable_time_to_first_upstream_rx_byte() {
  
  if (time_to_first_upstream_rx_byte_ == NULL) {
    time_to_first_upstream_rx_byte_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_first_upstream_rx_byte)
  return time_to_first_upstream_rx_byte_;
}
inline void AccessLogCommon::set_allocated_time_to_first_upstream_rx_byte(::google::protobuf::Duration* time_to_first_upstream_rx_byte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_first_upstream_rx_byte_);
  }
  if (time_to_first_upstream_rx_byte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_first_upstream_rx_byte)->GetArena();
    if (message_arena != submessage_arena) {
      time_to_first_upstream_rx_byte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_to_first_upstream_rx_byte, submessage_arena);
    }
    
  } else {
    
  }
  time_to_first_upstream_rx_byte_ = time_to_first_upstream_rx_byte;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_first_upstream_rx_byte)
}

// .google.protobuf.Duration time_to_last_upstream_rx_byte = 7;
inline bool AccessLogCommon::has_time_to_last_upstream_rx_byte() const {
  return this != internal_default_instance() && time_to_last_upstream_rx_byte_ != NULL;
}
inline const ::google::protobuf::Duration& AccessLogCommon::time_to_last_upstream_rx_byte() const {
  const ::google::protobuf::Duration* p = time_to_last_upstream_rx_byte_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_upstream_rx_byte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* AccessLogCommon::release_time_to_last_upstream_rx_byte() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_upstream_rx_byte)
  
  ::google::protobuf::Duration* temp = time_to_last_upstream_rx_byte_;
  time_to_last_upstream_rx_byte_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* AccessLogCommon::mutable_time_to_last_upstream_rx_byte() {
  
  if (time_to_last_upstream_rx_byte_ == NULL) {
    time_to_last_upstream_rx_byte_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_upstream_rx_byte)
  return time_to_last_upstream_rx_byte_;
}
inline void AccessLogCommon::set_allocated_time_to_last_upstream_rx_byte(::google::protobuf::Duration* time_to_last_upstream_rx_byte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_last_upstream_rx_byte_);
  }
  if (time_to_last_upstream_rx_byte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(time_to_last_upstream_rx_byte)->GetArena();
    if (message_arena != submessage_arena) {
      time_to_last_upstream_rx_byte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_to_last_upstream_rx_byte, submessage_arena);
    }
    
  } else {
    
  }
  time_to_last_upstream_rx_byte_ = time_to_last_upstream_rx_byte;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.time_to_last_upstream_rx_byte)
}

// .envoy.api.v2.SocketAddress upstream_host = 8;
inline bool AccessLogCommon::has_upstream_host() const {
  return this != internal_default_instance() && upstream_host_ != NULL;
}
inline const ::envoy::api::v2::SocketAddress& AccessLogCommon::upstream_host() const {
  const ::envoy::api::v2::SocketAddress* p = upstream_host_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_host)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::SocketAddress*>(
      &::envoy::api::v2::_SocketAddress_default_instance_);
}
inline ::envoy::api::v2::SocketAddress* AccessLogCommon::release_upstream_host() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_host)
  
  ::envoy::api::v2::SocketAddress* temp = upstream_host_;
  upstream_host_ = NULL;
  return temp;
}
inline ::envoy::api::v2::SocketAddress* AccessLogCommon::mutable_upstream_host() {
  
  if (upstream_host_ == NULL) {
    upstream_host_ = new ::envoy::api::v2::SocketAddress;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_host)
  return upstream_host_;
}
inline void AccessLogCommon::set_allocated_upstream_host(::envoy::api::v2::SocketAddress* upstream_host) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(upstream_host_);
  }
  if (upstream_host) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upstream_host = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upstream_host, submessage_arena);
    }
    
  } else {
    
  }
  upstream_host_ = upstream_host;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_host)
}

// string upstream_cluster = 9;
inline void AccessLogCommon::clear_upstream_cluster() {
  upstream_cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLogCommon::upstream_cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
  return upstream_cluster_.GetNoArena();
}
inline void AccessLogCommon::set_upstream_cluster(const ::std::string& value) {
  
  upstream_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
}
#if LANG_CXX11
inline void AccessLogCommon::set_upstream_cluster(::std::string&& value) {
  
  upstream_cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
}
#endif
inline void AccessLogCommon::set_upstream_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  upstream_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
}
inline void AccessLogCommon::set_upstream_cluster(const char* value, size_t size) {
  
  upstream_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
}
inline ::std::string* AccessLogCommon::mutable_upstream_cluster() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
  return upstream_cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLogCommon::release_upstream_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
  
  return upstream_cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLogCommon::set_allocated_upstream_cluster(::std::string* upstream_cluster) {
  if (upstream_cluster != NULL) {
    
  } else {
    
  }
  upstream_cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upstream_cluster);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.upstream_cluster)
}

// .envoy.api.v2.filter.accesslog.ResponseFlags response_flags = 10;
inline bool AccessLogCommon::has_response_flags() const {
  return this != internal_default_instance() && response_flags_ != NULL;
}
inline void AccessLogCommon::clear_response_flags() {
  if (GetArenaNoVirtual() == NULL && response_flags_ != NULL) {
    delete response_flags_;
  }
  response_flags_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::ResponseFlags& AccessLogCommon::response_flags() const {
  const ::envoy::api::v2::filter::accesslog::ResponseFlags* p = response_flags_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.response_flags)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::ResponseFlags*>(
      &::envoy::api::v2::filter::accesslog::_ResponseFlags_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::ResponseFlags* AccessLogCommon::release_response_flags() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.response_flags)
  
  ::envoy::api::v2::filter::accesslog::ResponseFlags* temp = response_flags_;
  response_flags_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::ResponseFlags* AccessLogCommon::mutable_response_flags() {
  
  if (response_flags_ == NULL) {
    response_flags_ = new ::envoy::api::v2::filter::accesslog::ResponseFlags;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.response_flags)
  return response_flags_;
}
inline void AccessLogCommon::set_allocated_response_flags(::envoy::api::v2::filter::accesslog::ResponseFlags* response_flags) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_flags_;
  }
  if (response_flags) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response_flags = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_flags, submessage_arena);
    }
    
  } else {
    
  }
  response_flags_ = response_flags;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.response_flags)
}

// .envoy.api.v2.Metadata metadata = 11;
inline bool AccessLogCommon::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline const ::envoy::api::v2::Metadata& AccessLogCommon::metadata() const {
  const ::envoy::api::v2::Metadata* p = metadata_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogCommon.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Metadata*>(
      &::envoy::api::v2::_Metadata_default_instance_);
}
inline ::envoy::api::v2::Metadata* AccessLogCommon::release_metadata() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogCommon.metadata)
  
  ::envoy::api::v2::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::envoy::api::v2::Metadata* AccessLogCommon::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::envoy::api::v2::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogCommon.metadata)
  return metadata_;
}
inline void AccessLogCommon::set_allocated_metadata(::envoy::api::v2::Metadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogCommon.metadata)
}

// -------------------------------------------------------------------

// ResponseFlags

// bool failed_local_healthcheck = 1;
inline void ResponseFlags::clear_failed_local_healthcheck() {
  failed_local_healthcheck_ = false;
}
inline bool ResponseFlags::failed_local_healthcheck() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.failed_local_healthcheck)
  return failed_local_healthcheck_;
}
inline void ResponseFlags::set_failed_local_healthcheck(bool value) {
  
  failed_local_healthcheck_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.failed_local_healthcheck)
}

// bool no_healthy_upstream = 2;
inline void ResponseFlags::clear_no_healthy_upstream() {
  no_healthy_upstream_ = false;
}
inline bool ResponseFlags::no_healthy_upstream() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.no_healthy_upstream)
  return no_healthy_upstream_;
}
inline void ResponseFlags::set_no_healthy_upstream(bool value) {
  
  no_healthy_upstream_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.no_healthy_upstream)
}

// bool upstream_request_timeout = 3;
inline void ResponseFlags::clear_upstream_request_timeout() {
  upstream_request_timeout_ = false;
}
inline bool ResponseFlags::upstream_request_timeout() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_request_timeout)
  return upstream_request_timeout_;
}
inline void ResponseFlags::set_upstream_request_timeout(bool value) {
  
  upstream_request_timeout_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_request_timeout)
}

// bool local_reset = 4;
inline void ResponseFlags::clear_local_reset() {
  local_reset_ = false;
}
inline bool ResponseFlags::local_reset() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.local_reset)
  return local_reset_;
}
inline void ResponseFlags::set_local_reset(bool value) {
  
  local_reset_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.local_reset)
}

// bool upstream_remote_reset = 5;
inline void ResponseFlags::clear_upstream_remote_reset() {
  upstream_remote_reset_ = false;
}
inline bool ResponseFlags::upstream_remote_reset() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_remote_reset)
  return upstream_remote_reset_;
}
inline void ResponseFlags::set_upstream_remote_reset(bool value) {
  
  upstream_remote_reset_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_remote_reset)
}

// bool upstream_connection_failure = 6;
inline void ResponseFlags::clear_upstream_connection_failure() {
  upstream_connection_failure_ = false;
}
inline bool ResponseFlags::upstream_connection_failure() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_connection_failure)
  return upstream_connection_failure_;
}
inline void ResponseFlags::set_upstream_connection_failure(bool value) {
  
  upstream_connection_failure_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_connection_failure)
}

// bool upstream_connection_termination = 7;
inline void ResponseFlags::clear_upstream_connection_termination() {
  upstream_connection_termination_ = false;
}
inline bool ResponseFlags::upstream_connection_termination() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_connection_termination)
  return upstream_connection_termination_;
}
inline void ResponseFlags::set_upstream_connection_termination(bool value) {
  
  upstream_connection_termination_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_connection_termination)
}

// bool upstream_overflow = 8;
inline void ResponseFlags::clear_upstream_overflow() {
  upstream_overflow_ = false;
}
inline bool ResponseFlags::upstream_overflow() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_overflow)
  return upstream_overflow_;
}
inline void ResponseFlags::set_upstream_overflow(bool value) {
  
  upstream_overflow_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.upstream_overflow)
}

// bool no_route_found = 9;
inline void ResponseFlags::clear_no_route_found() {
  no_route_found_ = false;
}
inline bool ResponseFlags::no_route_found() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.no_route_found)
  return no_route_found_;
}
inline void ResponseFlags::set_no_route_found(bool value) {
  
  no_route_found_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.no_route_found)
}

// bool delay_injected = 10;
inline void ResponseFlags::clear_delay_injected() {
  delay_injected_ = false;
}
inline bool ResponseFlags::delay_injected() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.delay_injected)
  return delay_injected_;
}
inline void ResponseFlags::set_delay_injected(bool value) {
  
  delay_injected_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.delay_injected)
}

// bool fault_injected = 11;
inline void ResponseFlags::clear_fault_injected() {
  fault_injected_ = false;
}
inline bool ResponseFlags::fault_injected() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.fault_injected)
  return fault_injected_;
}
inline void ResponseFlags::set_fault_injected(bool value) {
  
  fault_injected_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.fault_injected)
}

// bool rate_limited = 12;
inline void ResponseFlags::clear_rate_limited() {
  rate_limited_ = false;
}
inline bool ResponseFlags::rate_limited() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ResponseFlags.rate_limited)
  return rate_limited_;
}
inline void ResponseFlags::set_rate_limited(bool value) {
  
  rate_limited_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ResponseFlags.rate_limited)
}

// -------------------------------------------------------------------

// TLSProperties

// .envoy.api.v2.filter.accesslog.TLSProperties.TLSVersion tls_version = 1;
inline void TLSProperties::clear_tls_version() {
  tls_version_ = 0;
}
inline ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion TLSProperties::tls_version() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.TLSProperties.tls_version)
  return static_cast< ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion >(tls_version_);
}
inline void TLSProperties::set_tls_version(::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion value) {
  
  tls_version_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.TLSProperties.tls_version)
}

// .google.protobuf.UInt32Value tls_cipher_suite = 2;
inline bool TLSProperties::has_tls_cipher_suite() const {
  return this != internal_default_instance() && tls_cipher_suite_ != NULL;
}
inline const ::google::protobuf::UInt32Value& TLSProperties::tls_cipher_suite() const {
  const ::google::protobuf::UInt32Value* p = tls_cipher_suite_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.TLSProperties.tls_cipher_suite)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* TLSProperties::release_tls_cipher_suite() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.TLSProperties.tls_cipher_suite)
  
  ::google::protobuf::UInt32Value* temp = tls_cipher_suite_;
  tls_cipher_suite_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* TLSProperties::mutable_tls_cipher_suite() {
  
  if (tls_cipher_suite_ == NULL) {
    tls_cipher_suite_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.TLSProperties.tls_cipher_suite)
  return tls_cipher_suite_;
}
inline void TLSProperties::set_allocated_tls_cipher_suite(::google::protobuf::UInt32Value* tls_cipher_suite) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tls_cipher_suite_);
  }
  if (tls_cipher_suite) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(tls_cipher_suite)->GetArena();
    if (message_arena != submessage_arena) {
      tls_cipher_suite = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls_cipher_suite, submessage_arena);
    }
    
  } else {
    
  }
  tls_cipher_suite_ = tls_cipher_suite;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.TLSProperties.tls_cipher_suite)
}

// string tls_sni_hostname = 3;
inline void TLSProperties::clear_tls_sni_hostname() {
  tls_sni_hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLSProperties::tls_sni_hostname() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
  return tls_sni_hostname_.GetNoArena();
}
inline void TLSProperties::set_tls_sni_hostname(const ::std::string& value) {
  
  tls_sni_hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
}
#if LANG_CXX11
inline void TLSProperties::set_tls_sni_hostname(::std::string&& value) {
  
  tls_sni_hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
}
#endif
inline void TLSProperties::set_tls_sni_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tls_sni_hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
}
inline void TLSProperties::set_tls_sni_hostname(const char* value, size_t size) {
  
  tls_sni_hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
}
inline ::std::string* TLSProperties::mutable_tls_sni_hostname() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
  return tls_sni_hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLSProperties::release_tls_sni_hostname() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
  
  return tls_sni_hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLSProperties::set_allocated_tls_sni_hostname(::std::string* tls_sni_hostname) {
  if (tls_sni_hostname != NULL) {
    
  } else {
    
  }
  tls_sni_hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tls_sni_hostname);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.TLSProperties.tls_sni_hostname)
}

// -------------------------------------------------------------------

// TCPAccessLogEntry

// .envoy.api.v2.filter.accesslog.AccessLogCommon common_properties = 1;
inline bool TCPAccessLogEntry::has_common_properties() const {
  return this != internal_default_instance() && common_properties_ != NULL;
}
inline void TCPAccessLogEntry::clear_common_properties() {
  if (GetArenaNoVirtual() == NULL && common_properties_ != NULL) {
    delete common_properties_;
  }
  common_properties_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::AccessLogCommon& TCPAccessLogEntry::common_properties() const {
  const ::envoy::api::v2::filter::accesslog::AccessLogCommon* p = common_properties_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.TCPAccessLogEntry.common_properties)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::AccessLogCommon*>(
      &::envoy::api::v2::filter::accesslog::_AccessLogCommon_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogCommon* TCPAccessLogEntry::release_common_properties() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.TCPAccessLogEntry.common_properties)
  
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* temp = common_properties_;
  common_properties_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::AccessLogCommon* TCPAccessLogEntry::mutable_common_properties() {
  
  if (common_properties_ == NULL) {
    common_properties_ = new ::envoy::api::v2::filter::accesslog::AccessLogCommon;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.TCPAccessLogEntry.common_properties)
  return common_properties_;
}
inline void TCPAccessLogEntry::set_allocated_common_properties(::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_properties_;
  }
  if (common_properties) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common_properties = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common_properties, submessage_arena);
    }
    
  } else {
    
  }
  common_properties_ = common_properties;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.TCPAccessLogEntry.common_properties)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HTTPRequestProperties

// .envoy.api.v2.RequestMethod request_method = 1;
inline void HTTPRequestProperties::clear_request_method() {
  request_method_ = 0;
}
inline ::envoy::api::v2::RequestMethod HTTPRequestProperties::request_method() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_method)
  return static_cast< ::envoy::api::v2::RequestMethod >(request_method_);
}
inline void HTTPRequestProperties::set_request_method(::envoy::api::v2::RequestMethod value) {
  
  request_method_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_method)
}

// string scheme = 2;
inline void HTTPRequestProperties::clear_scheme() {
  scheme_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::scheme() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
  return scheme_.GetNoArena();
}
inline void HTTPRequestProperties::set_scheme(const ::std::string& value) {
  
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_scheme(::std::string&& value) {
  
  scheme_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
}
#endif
inline void HTTPRequestProperties::set_scheme(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
}
inline void HTTPRequestProperties::set_scheme(const char* value, size_t size) {
  
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
}
inline ::std::string* HTTPRequestProperties::mutable_scheme() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
  return scheme_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_scheme() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
  
  return scheme_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_scheme(::std::string* scheme) {
  if (scheme != NULL) {
    
  } else {
    
  }
  scheme_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheme);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.scheme)
}

// string authority = 3;
inline void HTTPRequestProperties::clear_authority() {
  authority_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::authority() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
  return authority_.GetNoArena();
}
inline void HTTPRequestProperties::set_authority(const ::std::string& value) {
  
  authority_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_authority(::std::string&& value) {
  
  authority_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
}
#endif
inline void HTTPRequestProperties::set_authority(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  authority_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
}
inline void HTTPRequestProperties::set_authority(const char* value, size_t size) {
  
  authority_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
}
inline ::std::string* HTTPRequestProperties::mutable_authority() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
  return authority_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_authority() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
  
  return authority_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_authority(::std::string* authority) {
  if (authority != NULL) {
    
  } else {
    
  }
  authority_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authority);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.authority)
}

// .google.protobuf.UInt32Value port = 4;
inline bool HTTPRequestProperties::has_port() const {
  return this != internal_default_instance() && port_ != NULL;
}
inline const ::google::protobuf::UInt32Value& HTTPRequestProperties::port() const {
  const ::google::protobuf::UInt32Value* p = port_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.port)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* HTTPRequestProperties::release_port() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.port)
  
  ::google::protobuf::UInt32Value* temp = port_;
  port_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* HTTPRequestProperties::mutable_port() {
  
  if (port_ == NULL) {
    port_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.port)
  return port_;
}
inline void HTTPRequestProperties::set_allocated_port(::google::protobuf::UInt32Value* port) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(port_);
  }
  if (port) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(port)->GetArena();
    if (message_arena != submessage_arena) {
      port = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port, submessage_arena);
    }
    
  } else {
    
  }
  port_ = port;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.port)
}

// string path = 5;
inline void HTTPRequestProperties::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
  return path_.GetNoArena();
}
inline void HTTPRequestProperties::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
}
#endif
inline void HTTPRequestProperties::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
}
inline void HTTPRequestProperties::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
}
inline ::std::string* HTTPRequestProperties::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.path)
}

// string user_agent = 6;
inline void HTTPRequestProperties::clear_user_agent() {
  user_agent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::user_agent() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
  return user_agent_.GetNoArena();
}
inline void HTTPRequestProperties::set_user_agent(const ::std::string& value) {
  
  user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_user_agent(::std::string&& value) {
  
  user_agent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
}
#endif
inline void HTTPRequestProperties::set_user_agent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
}
inline void HTTPRequestProperties::set_user_agent(const char* value, size_t size) {
  
  user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
}
inline ::std::string* HTTPRequestProperties::mutable_user_agent() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
  return user_agent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_user_agent() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
  
  return user_agent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_user_agent(::std::string* user_agent) {
  if (user_agent != NULL) {
    
  } else {
    
  }
  user_agent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_agent);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.user_agent)
}

// string referer = 7;
inline void HTTPRequestProperties::clear_referer() {
  referer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::referer() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
  return referer_.GetNoArena();
}
inline void HTTPRequestProperties::set_referer(const ::std::string& value) {
  
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_referer(::std::string&& value) {
  
  referer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
}
#endif
inline void HTTPRequestProperties::set_referer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
}
inline void HTTPRequestProperties::set_referer(const char* value, size_t size) {
  
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
}
inline ::std::string* HTTPRequestProperties::mutable_referer() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
  return referer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_referer() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
  
  return referer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_referer(::std::string* referer) {
  if (referer != NULL) {
    
  } else {
    
  }
  referer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referer);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.referer)
}

// string forwarded_for = 8;
inline void HTTPRequestProperties::clear_forwarded_for() {
  forwarded_for_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::forwarded_for() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
  return forwarded_for_.GetNoArena();
}
inline void HTTPRequestProperties::set_forwarded_for(const ::std::string& value) {
  
  forwarded_for_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_forwarded_for(::std::string&& value) {
  
  forwarded_for_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
}
#endif
inline void HTTPRequestProperties::set_forwarded_for(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  forwarded_for_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
}
inline void HTTPRequestProperties::set_forwarded_for(const char* value, size_t size) {
  
  forwarded_for_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
}
inline ::std::string* HTTPRequestProperties::mutable_forwarded_for() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
  return forwarded_for_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_forwarded_for() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
  
  return forwarded_for_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_forwarded_for(::std::string* forwarded_for) {
  if (forwarded_for != NULL) {
    
  } else {
    
  }
  forwarded_for_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), forwarded_for);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.forwarded_for)
}

// string request_id = 9;
inline void HTTPRequestProperties::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::request_id() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
  return request_id_.GetNoArena();
}
inline void HTTPRequestProperties::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
}
#endif
inline void HTTPRequestProperties::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
}
inline void HTTPRequestProperties::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
}
inline ::std::string* HTTPRequestProperties::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_request_id() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_request_id(::std::string* request_id) {
  if (request_id != NULL) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_id)
}

// string original_path = 10;
inline void HTTPRequestProperties::clear_original_path() {
  original_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPRequestProperties::original_path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
  return original_path_.GetNoArena();
}
inline void HTTPRequestProperties::set_original_path(const ::std::string& value) {
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
}
#if LANG_CXX11
inline void HTTPRequestProperties::set_original_path(::std::string&& value) {
  
  original_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
}
#endif
inline void HTTPRequestProperties::set_original_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
}
inline void HTTPRequestProperties::set_original_path(const char* value, size_t size) {
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
}
inline ::std::string* HTTPRequestProperties::mutable_original_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
  return original_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPRequestProperties::release_original_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
  
  return original_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPRequestProperties::set_allocated_original_path(::std::string* original_path) {
  if (original_path != NULL) {
    
  } else {
    
  }
  original_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), original_path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPRequestProperties.original_path)
}

// uint64 request_headers_bytes = 11;
inline void HTTPRequestProperties::clear_request_headers_bytes() {
  request_headers_bytes_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HTTPRequestProperties::request_headers_bytes() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_headers_bytes)
  return request_headers_bytes_;
}
inline void HTTPRequestProperties::set_request_headers_bytes(::google::protobuf::uint64 value) {
  
  request_headers_bytes_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_headers_bytes)
}

// uint64 request_body_bytes = 12;
inline void HTTPRequestProperties::clear_request_body_bytes() {
  request_body_bytes_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HTTPRequestProperties::request_body_bytes() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_body_bytes)
  return request_body_bytes_;
}
inline void HTTPRequestProperties::set_request_body_bytes(::google::protobuf::uint64 value) {
  
  request_body_bytes_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_body_bytes)
}

// map<string, string> request_headers = 13;
inline int HTTPRequestProperties::request_headers_size() const {
  return request_headers_.size();
}
inline void HTTPRequestProperties::clear_request_headers() {
  request_headers_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HTTPRequestProperties::request_headers() const {
  // @@protoc_insertion_point(field_map:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_headers)
  return request_headers_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HTTPRequestProperties::mutable_request_headers() {
  // @@protoc_insertion_point(field_mutable_map:envoy.api.v2.filter.accesslog.HTTPRequestProperties.request_headers)
  return request_headers_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HTTPResponseProperties

// .google.protobuf.UInt32Value response_code = 1;
inline bool HTTPResponseProperties::has_response_code() const {
  return this != internal_default_instance() && response_code_ != NULL;
}
inline const ::google::protobuf::UInt32Value& HTTPResponseProperties::response_code() const {
  const ::google::protobuf::UInt32Value* p = response_code_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_code)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* HTTPResponseProperties::release_response_code() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_code)
  
  ::google::protobuf::UInt32Value* temp = response_code_;
  response_code_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* HTTPResponseProperties::mutable_response_code() {
  
  if (response_code_ == NULL) {
    response_code_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_code)
  return response_code_;
}
inline void HTTPResponseProperties::set_allocated_response_code(::google::protobuf::UInt32Value* response_code) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(response_code_);
  }
  if (response_code) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(response_code)->GetArena();
    if (message_arena != submessage_arena) {
      response_code = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_code, submessage_arena);
    }
    
  } else {
    
  }
  response_code_ = response_code;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_code)
}

// uint64 response_headers_bytes = 2;
inline void HTTPResponseProperties::clear_response_headers_bytes() {
  response_headers_bytes_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HTTPResponseProperties::response_headers_bytes() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_headers_bytes)
  return response_headers_bytes_;
}
inline void HTTPResponseProperties::set_response_headers_bytes(::google::protobuf::uint64 value) {
  
  response_headers_bytes_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_headers_bytes)
}

// uint64 response_body_bytes = 3;
inline void HTTPResponseProperties::clear_response_body_bytes() {
  response_body_bytes_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HTTPResponseProperties::response_body_bytes() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_body_bytes)
  return response_body_bytes_;
}
inline void HTTPResponseProperties::set_response_body_bytes(::google::protobuf::uint64 value) {
  
  response_body_bytes_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_body_bytes)
}

// map<string, string> response_headers = 4;
inline int HTTPResponseProperties::response_headers_size() const {
  return response_headers_.size();
}
inline void HTTPResponseProperties::clear_response_headers() {
  response_headers_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HTTPResponseProperties::response_headers() const {
  // @@protoc_insertion_point(field_map:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_headers)
  return response_headers_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HTTPResponseProperties::mutable_response_headers() {
  // @@protoc_insertion_point(field_mutable_map:envoy.api.v2.filter.accesslog.HTTPResponseProperties.response_headers)
  return response_headers_.MutableMap();
}

// -------------------------------------------------------------------

// HTTPAccessLogEntry

// .envoy.api.v2.filter.accesslog.AccessLogCommon common_properties = 1;
inline bool HTTPAccessLogEntry::has_common_properties() const {
  return this != internal_default_instance() && common_properties_ != NULL;
}
inline void HTTPAccessLogEntry::clear_common_properties() {
  if (GetArenaNoVirtual() == NULL && common_properties_ != NULL) {
    delete common_properties_;
  }
  common_properties_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::AccessLogCommon& HTTPAccessLogEntry::common_properties() const {
  const ::envoy::api::v2::filter::accesslog::AccessLogCommon* p = common_properties_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.common_properties)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::AccessLogCommon*>(
      &::envoy::api::v2::filter::accesslog::_AccessLogCommon_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogCommon* HTTPAccessLogEntry::release_common_properties() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.common_properties)
  
  ::envoy::api::v2::filter::accesslog::AccessLogCommon* temp = common_properties_;
  common_properties_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::AccessLogCommon* HTTPAccessLogEntry::mutable_common_properties() {
  
  if (common_properties_ == NULL) {
    common_properties_ = new ::envoy::api::v2::filter::accesslog::AccessLogCommon;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.common_properties)
  return common_properties_;
}
inline void HTTPAccessLogEntry::set_allocated_common_properties(::envoy::api::v2::filter::accesslog::AccessLogCommon* common_properties) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_properties_;
  }
  if (common_properties) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common_properties = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common_properties, submessage_arena);
    }
    
  } else {
    
  }
  common_properties_ = common_properties;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.common_properties)
}

// .envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.HTTPVersion protocol_version = 2;
inline void HTTPAccessLogEntry::clear_protocol_version() {
  protocol_version_ = 0;
}
inline ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion HTTPAccessLogEntry::protocol_version() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.protocol_version)
  return static_cast< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion >(protocol_version_);
}
inline void HTTPAccessLogEntry::set_protocol_version(::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion value) {
  
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.protocol_version)
}

// .envoy.api.v2.filter.accesslog.HTTPRequestProperties request = 3;
inline bool HTTPAccessLogEntry::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void HTTPAccessLogEntry::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) {
    delete request_;
  }
  request_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::HTTPRequestProperties& HTTPAccessLogEntry::request() const {
  const ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* p = request_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.request)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::HTTPRequestProperties*>(
      &::envoy::api::v2::filter::accesslog::_HTTPRequestProperties_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* HTTPAccessLogEntry::release_request() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.request)
  
  ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::HTTPRequestProperties* HTTPAccessLogEntry::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::envoy::api::v2::filter::accesslog::HTTPRequestProperties;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.request)
  return request_;
}
inline void HTTPAccessLogEntry::set_allocated_request(::envoy::api::v2::filter::accesslog::HTTPRequestProperties* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.request)
}

// .envoy.api.v2.filter.accesslog.HTTPResponseProperties response = 4;
inline bool HTTPAccessLogEntry::has_response() const {
  return this != internal_default_instance() && response_ != NULL;
}
inline void HTTPAccessLogEntry::clear_response() {
  if (GetArenaNoVirtual() == NULL && response_ != NULL) {
    delete response_;
  }
  response_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::HTTPResponseProperties& HTTPAccessLogEntry::response() const {
  const ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* p = response_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.response)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::HTTPResponseProperties*>(
      &::envoy::api::v2::filter::accesslog::_HTTPResponseProperties_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* HTTPAccessLogEntry::release_response() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.response)
  
  ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* temp = response_;
  response_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::HTTPResponseProperties* HTTPAccessLogEntry::mutable_response() {
  
  if (response_ == NULL) {
    response_ = new ::envoy::api::v2::filter::accesslog::HTTPResponseProperties;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.response)
  return response_;
}
inline void HTTPAccessLogEntry::set_allocated_response(::envoy::api::v2::filter::accesslog::HTTPResponseProperties* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.HTTPAccessLogEntry.response)
}

// -------------------------------------------------------------------

// ComparisonFilter

// .envoy.api.v2.filter.accesslog.ComparisonFilter.Op op = 1;
inline void ComparisonFilter::clear_op() {
  op_ = 0;
}
inline ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op ComparisonFilter::op() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ComparisonFilter.op)
  return static_cast< ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op >(op_);
}
inline void ComparisonFilter::set_op(::envoy::api::v2::filter::accesslog::ComparisonFilter_Op value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.ComparisonFilter.op)
}

// .envoy.api.v2.RuntimeUInt32 value = 2;
inline bool ComparisonFilter::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::envoy::api::v2::RuntimeUInt32& ComparisonFilter::value() const {
  const ::envoy::api::v2::RuntimeUInt32* p = value_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.ComparisonFilter.value)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RuntimeUInt32*>(
      &::envoy::api::v2::_RuntimeUInt32_default_instance_);
}
inline ::envoy::api::v2::RuntimeUInt32* ComparisonFilter::release_value() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.ComparisonFilter.value)
  
  ::envoy::api::v2::RuntimeUInt32* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::envoy::api::v2::RuntimeUInt32* ComparisonFilter::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::envoy::api::v2::RuntimeUInt32;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.ComparisonFilter.value)
  return value_;
}
inline void ComparisonFilter::set_allocated_value(::envoy::api::v2::RuntimeUInt32* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.ComparisonFilter.value)
}

// -------------------------------------------------------------------

// StatusCodeFilter

// .envoy.api.v2.filter.accesslog.ComparisonFilter comparison = 1;
inline bool StatusCodeFilter::has_comparison() const {
  return this != internal_default_instance() && comparison_ != NULL;
}
inline void StatusCodeFilter::clear_comparison() {
  if (GetArenaNoVirtual() == NULL && comparison_ != NULL) {
    delete comparison_;
  }
  comparison_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::ComparisonFilter& StatusCodeFilter::comparison() const {
  const ::envoy::api::v2::filter::accesslog::ComparisonFilter* p = comparison_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StatusCodeFilter.comparison)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::ComparisonFilter*>(
      &::envoy::api::v2::filter::accesslog::_ComparisonFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::ComparisonFilter* StatusCodeFilter::release_comparison() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StatusCodeFilter.comparison)
  
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* temp = comparison_;
  comparison_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::ComparisonFilter* StatusCodeFilter::mutable_comparison() {
  
  if (comparison_ == NULL) {
    comparison_ = new ::envoy::api::v2::filter::accesslog::ComparisonFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StatusCodeFilter.comparison)
  return comparison_;
}
inline void StatusCodeFilter::set_allocated_comparison(::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete comparison_;
  }
  if (comparison) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      comparison = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, comparison, submessage_arena);
    }
    
  } else {
    
  }
  comparison_ = comparison;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.StatusCodeFilter.comparison)
}

// -------------------------------------------------------------------

// DurationFilter

// .envoy.api.v2.filter.accesslog.ComparisonFilter comparison = 1;
inline bool DurationFilter::has_comparison() const {
  return this != internal_default_instance() && comparison_ != NULL;
}
inline void DurationFilter::clear_comparison() {
  if (GetArenaNoVirtual() == NULL && comparison_ != NULL) {
    delete comparison_;
  }
  comparison_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::ComparisonFilter& DurationFilter::comparison() const {
  const ::envoy::api::v2::filter::accesslog::ComparisonFilter* p = comparison_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.DurationFilter.comparison)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::ComparisonFilter*>(
      &::envoy::api::v2::filter::accesslog::_ComparisonFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::ComparisonFilter* DurationFilter::release_comparison() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.DurationFilter.comparison)
  
  ::envoy::api::v2::filter::accesslog::ComparisonFilter* temp = comparison_;
  comparison_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::ComparisonFilter* DurationFilter::mutable_comparison() {
  
  if (comparison_ == NULL) {
    comparison_ = new ::envoy::api::v2::filter::accesslog::ComparisonFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.DurationFilter.comparison)
  return comparison_;
}
inline void DurationFilter::set_allocated_comparison(::envoy::api::v2::filter::accesslog::ComparisonFilter* comparison) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete comparison_;
  }
  if (comparison) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      comparison = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, comparison, submessage_arena);
    }
    
  } else {
    
  }
  comparison_ = comparison;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.DurationFilter.comparison)
}

// -------------------------------------------------------------------

// NotHealthCheckFilter

// -------------------------------------------------------------------

// TraceableFilter

// -------------------------------------------------------------------

// RuntimeFilter

// string runtime_key = 1;
inline void RuntimeFilter::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeFilter::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RuntimeFilter::set_runtime_key(const ::std::string& value) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
}
#if LANG_CXX11
inline void RuntimeFilter::set_runtime_key(::std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
}
#endif
inline void RuntimeFilter::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
}
inline void RuntimeFilter::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
}
inline ::std::string* RuntimeFilter::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
  return runtime_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeFilter::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeFilter::set_allocated_runtime_key(::std::string* runtime_key) {
  if (runtime_key != NULL) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.RuntimeFilter.runtime_key)
}

// -------------------------------------------------------------------

// AndFilter

// repeated .envoy.api.v2.filter.accesslog.AccessLogFilter filters = 1;
inline int AndFilter::filters_size() const {
  return filters_.size();
}
inline void AndFilter::clear_filters() {
  filters_.Clear();
}
inline const ::envoy::api::v2::filter::accesslog::AccessLogFilter& AndFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AndFilter.filters)
  return filters_.Get(index);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* AndFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AndFilter.filters)
  return filters_.Mutable(index);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* AndFilter::add_filters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.accesslog.AndFilter.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >*
AndFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.accesslog.AndFilter.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >&
AndFilter::filters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.accesslog.AndFilter.filters)
  return filters_;
}

// -------------------------------------------------------------------

// OrFilter

// repeated .envoy.api.v2.filter.accesslog.AccessLogFilter filters = 2;
inline int OrFilter::filters_size() const {
  return filters_.size();
}
inline void OrFilter::clear_filters() {
  filters_.Clear();
}
inline const ::envoy::api::v2::filter::accesslog::AccessLogFilter& OrFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.OrFilter.filters)
  return filters_.Get(index);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* OrFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.OrFilter.filters)
  return filters_.Mutable(index);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* OrFilter::add_filters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.accesslog.OrFilter.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >*
OrFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.accesslog.OrFilter.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::AccessLogFilter >&
OrFilter::filters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.accesslog.OrFilter.filters)
  return filters_;
}

// -------------------------------------------------------------------

// AccessLogFilter

// .envoy.api.v2.filter.accesslog.StatusCodeFilter status_code_filter = 1;
inline bool AccessLogFilter::has_status_code_filter() const {
  return filter_specifier_case() == kStatusCodeFilter;
}
inline void AccessLogFilter::set_has_status_code_filter() {
  _oneof_case_[0] = kStatusCodeFilter;
}
inline void AccessLogFilter::clear_status_code_filter() {
  if (has_status_code_filter()) {
    delete filter_specifier_.status_code_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::StatusCodeFilter* AccessLogFilter::release_status_code_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.status_code_filter)
  if (has_status_code_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::StatusCodeFilter* temp = filter_specifier_.status_code_filter_;
    filter_specifier_.status_code_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::StatusCodeFilter& AccessLogFilter::status_code_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.status_code_filter)
  return has_status_code_filter()
      ? *filter_specifier_.status_code_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::StatusCodeFilter*>(&::envoy::api::v2::filter::accesslog::_StatusCodeFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::StatusCodeFilter* AccessLogFilter::mutable_status_code_filter() {
  if (!has_status_code_filter()) {
    clear_filter_specifier();
    set_has_status_code_filter();
    filter_specifier_.status_code_filter_ = new ::envoy::api::v2::filter::accesslog::StatusCodeFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.status_code_filter)
  return filter_specifier_.status_code_filter_;
}

// .envoy.api.v2.filter.accesslog.DurationFilter duration_filter = 2;
inline bool AccessLogFilter::has_duration_filter() const {
  return filter_specifier_case() == kDurationFilter;
}
inline void AccessLogFilter::set_has_duration_filter() {
  _oneof_case_[0] = kDurationFilter;
}
inline void AccessLogFilter::clear_duration_filter() {
  if (has_duration_filter()) {
    delete filter_specifier_.duration_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::DurationFilter* AccessLogFilter::release_duration_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.duration_filter)
  if (has_duration_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::DurationFilter* temp = filter_specifier_.duration_filter_;
    filter_specifier_.duration_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::DurationFilter& AccessLogFilter::duration_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.duration_filter)
  return has_duration_filter()
      ? *filter_specifier_.duration_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::DurationFilter*>(&::envoy::api::v2::filter::accesslog::_DurationFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::DurationFilter* AccessLogFilter::mutable_duration_filter() {
  if (!has_duration_filter()) {
    clear_filter_specifier();
    set_has_duration_filter();
    filter_specifier_.duration_filter_ = new ::envoy::api::v2::filter::accesslog::DurationFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.duration_filter)
  return filter_specifier_.duration_filter_;
}

// .envoy.api.v2.filter.accesslog.NotHealthCheckFilter not_health_check_filter = 3;
inline bool AccessLogFilter::has_not_health_check_filter() const {
  return filter_specifier_case() == kNotHealthCheckFilter;
}
inline void AccessLogFilter::set_has_not_health_check_filter() {
  _oneof_case_[0] = kNotHealthCheckFilter;
}
inline void AccessLogFilter::clear_not_health_check_filter() {
  if (has_not_health_check_filter()) {
    delete filter_specifier_.not_health_check_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* AccessLogFilter::release_not_health_check_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.not_health_check_filter)
  if (has_not_health_check_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* temp = filter_specifier_.not_health_check_filter_;
    filter_specifier_.not_health_check_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter& AccessLogFilter::not_health_check_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.not_health_check_filter)
  return has_not_health_check_filter()
      ? *filter_specifier_.not_health_check_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter*>(&::envoy::api::v2::filter::accesslog::_NotHealthCheckFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter* AccessLogFilter::mutable_not_health_check_filter() {
  if (!has_not_health_check_filter()) {
    clear_filter_specifier();
    set_has_not_health_check_filter();
    filter_specifier_.not_health_check_filter_ = new ::envoy::api::v2::filter::accesslog::NotHealthCheckFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.not_health_check_filter)
  return filter_specifier_.not_health_check_filter_;
}

// .envoy.api.v2.filter.accesslog.TraceableFilter traceable_filter = 4;
inline bool AccessLogFilter::has_traceable_filter() const {
  return filter_specifier_case() == kTraceableFilter;
}
inline void AccessLogFilter::set_has_traceable_filter() {
  _oneof_case_[0] = kTraceableFilter;
}
inline void AccessLogFilter::clear_traceable_filter() {
  if (has_traceable_filter()) {
    delete filter_specifier_.traceable_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::TraceableFilter* AccessLogFilter::release_traceable_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.traceable_filter)
  if (has_traceable_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::TraceableFilter* temp = filter_specifier_.traceable_filter_;
    filter_specifier_.traceable_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::TraceableFilter& AccessLogFilter::traceable_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.traceable_filter)
  return has_traceable_filter()
      ? *filter_specifier_.traceable_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::TraceableFilter*>(&::envoy::api::v2::filter::accesslog::_TraceableFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::TraceableFilter* AccessLogFilter::mutable_traceable_filter() {
  if (!has_traceable_filter()) {
    clear_filter_specifier();
    set_has_traceable_filter();
    filter_specifier_.traceable_filter_ = new ::envoy::api::v2::filter::accesslog::TraceableFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.traceable_filter)
  return filter_specifier_.traceable_filter_;
}

// .envoy.api.v2.filter.accesslog.RuntimeFilter runtime_filter = 5;
inline bool AccessLogFilter::has_runtime_filter() const {
  return filter_specifier_case() == kRuntimeFilter;
}
inline void AccessLogFilter::set_has_runtime_filter() {
  _oneof_case_[0] = kRuntimeFilter;
}
inline void AccessLogFilter::clear_runtime_filter() {
  if (has_runtime_filter()) {
    delete filter_specifier_.runtime_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::RuntimeFilter* AccessLogFilter::release_runtime_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.runtime_filter)
  if (has_runtime_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::RuntimeFilter* temp = filter_specifier_.runtime_filter_;
    filter_specifier_.runtime_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::RuntimeFilter& AccessLogFilter::runtime_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.runtime_filter)
  return has_runtime_filter()
      ? *filter_specifier_.runtime_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::RuntimeFilter*>(&::envoy::api::v2::filter::accesslog::_RuntimeFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::RuntimeFilter* AccessLogFilter::mutable_runtime_filter() {
  if (!has_runtime_filter()) {
    clear_filter_specifier();
    set_has_runtime_filter();
    filter_specifier_.runtime_filter_ = new ::envoy::api::v2::filter::accesslog::RuntimeFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.runtime_filter)
  return filter_specifier_.runtime_filter_;
}

// .envoy.api.v2.filter.accesslog.AndFilter and_filter = 6;
inline bool AccessLogFilter::has_and_filter() const {
  return filter_specifier_case() == kAndFilter;
}
inline void AccessLogFilter::set_has_and_filter() {
  _oneof_case_[0] = kAndFilter;
}
inline void AccessLogFilter::clear_and_filter() {
  if (has_and_filter()) {
    delete filter_specifier_.and_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::AndFilter* AccessLogFilter::release_and_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.and_filter)
  if (has_and_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::AndFilter* temp = filter_specifier_.and_filter_;
    filter_specifier_.and_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::AndFilter& AccessLogFilter::and_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.and_filter)
  return has_and_filter()
      ? *filter_specifier_.and_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::AndFilter*>(&::envoy::api::v2::filter::accesslog::_AndFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::AndFilter* AccessLogFilter::mutable_and_filter() {
  if (!has_and_filter()) {
    clear_filter_specifier();
    set_has_and_filter();
    filter_specifier_.and_filter_ = new ::envoy::api::v2::filter::accesslog::AndFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.and_filter)
  return filter_specifier_.and_filter_;
}

// .envoy.api.v2.filter.accesslog.OrFilter or_filter = 7;
inline bool AccessLogFilter::has_or_filter() const {
  return filter_specifier_case() == kOrFilter;
}
inline void AccessLogFilter::set_has_or_filter() {
  _oneof_case_[0] = kOrFilter;
}
inline void AccessLogFilter::clear_or_filter() {
  if (has_or_filter()) {
    delete filter_specifier_.or_filter_;
    clear_has_filter_specifier();
  }
}
inline ::envoy::api::v2::filter::accesslog::OrFilter* AccessLogFilter::release_or_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogFilter.or_filter)
  if (has_or_filter()) {
    clear_has_filter_specifier();
      ::envoy::api::v2::filter::accesslog::OrFilter* temp = filter_specifier_.or_filter_;
    filter_specifier_.or_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::OrFilter& AccessLogFilter::or_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogFilter.or_filter)
  return has_or_filter()
      ? *filter_specifier_.or_filter_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::OrFilter*>(&::envoy::api::v2::filter::accesslog::_OrFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::OrFilter* AccessLogFilter::mutable_or_filter() {
  if (!has_or_filter()) {
    clear_filter_specifier();
    set_has_or_filter();
    filter_specifier_.or_filter_ = new ::envoy::api::v2::filter::accesslog::OrFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogFilter.or_filter)
  return filter_specifier_.or_filter_;
}

inline bool AccessLogFilter::has_filter_specifier() const {
  return filter_specifier_case() != FILTER_SPECIFIER_NOT_SET;
}
inline void AccessLogFilter::clear_has_filter_specifier() {
  _oneof_case_[0] = FILTER_SPECIFIER_NOT_SET;
}
inline AccessLogFilter::FilterSpecifierCase AccessLogFilter::filter_specifier_case() const {
  return AccessLogFilter::FilterSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileAccessLog

// string path = 1;
inline void FileAccessLog::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileAccessLog::path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.FileAccessLog.path)
  return path_.GetNoArena();
}
inline void FileAccessLog::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.FileAccessLog.path)
}
#if LANG_CXX11
inline void FileAccessLog::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.FileAccessLog.path)
}
#endif
inline void FileAccessLog::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.FileAccessLog.path)
}
inline void FileAccessLog::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.FileAccessLog.path)
}
inline ::std::string* FileAccessLog::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.FileAccessLog.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileAccessLog::release_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.FileAccessLog.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileAccessLog::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.FileAccessLog.path)
}

// string format = 2;
inline void FileAccessLog::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileAccessLog::format() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.FileAccessLog.format)
  return format_.GetNoArena();
}
inline void FileAccessLog::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.FileAccessLog.format)
}
#if LANG_CXX11
inline void FileAccessLog::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.FileAccessLog.format)
}
#endif
inline void FileAccessLog::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.FileAccessLog.format)
}
inline void FileAccessLog::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.FileAccessLog.format)
}
inline ::std::string* FileAccessLog::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.FileAccessLog.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileAccessLog::release_format() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.FileAccessLog.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileAccessLog::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.FileAccessLog.format)
}

// -------------------------------------------------------------------

// AccessLogServiceConfig

// string log_name = 1;
inline void AccessLogServiceConfig::clear_log_name() {
  log_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLogServiceConfig::log_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
  return log_name_.GetNoArena();
}
inline void AccessLogServiceConfig::set_log_name(const ::std::string& value) {
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
}
#if LANG_CXX11
inline void AccessLogServiceConfig::set_log_name(::std::string&& value) {
  
  log_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
}
#endif
inline void AccessLogServiceConfig::set_log_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
}
inline void AccessLogServiceConfig::set_log_name(const char* value, size_t size) {
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
}
inline ::std::string* AccessLogServiceConfig::mutable_log_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
  return log_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLogServiceConfig::release_log_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
  
  return log_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLogServiceConfig::set_allocated_log_name(::std::string* log_name) {
  if (log_name != NULL) {
    
  } else {
    
  }
  log_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.log_name)
}

// string cluster_name = 2;
inline void AccessLogServiceConfig::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLogServiceConfig::cluster_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void AccessLogServiceConfig::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
}
#if LANG_CXX11
inline void AccessLogServiceConfig::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
}
#endif
inline void AccessLogServiceConfig::set_cluster_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
}
inline void AccessLogServiceConfig::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
}
inline ::std::string* AccessLogServiceConfig::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLogServiceConfig::release_cluster_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLogServiceConfig::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLogServiceConfig.cluster_name)
}

// -------------------------------------------------------------------

// StreamAccessLogsMessage_Identifier

// .envoy.api.v2.Node node = 1;
inline bool StreamAccessLogsMessage_Identifier::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline const ::envoy::api::v2::Node& StreamAccessLogsMessage_Identifier::node() const {
  const ::envoy::api::v2::Node* p = node_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.node)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Node*>(
      &::envoy::api::v2::_Node_default_instance_);
}
inline ::envoy::api::v2::Node* StreamAccessLogsMessage_Identifier::release_node() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.node)
  
  ::envoy::api::v2::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::envoy::api::v2::Node* StreamAccessLogsMessage_Identifier::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::envoy::api::v2::Node;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.node)
  return node_;
}
inline void StreamAccessLogsMessage_Identifier::set_allocated_node(::envoy::api::v2::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.node)
}

// string log_name = 2;
inline void StreamAccessLogsMessage_Identifier::clear_log_name() {
  log_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StreamAccessLogsMessage_Identifier::log_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
  return log_name_.GetNoArena();
}
inline void StreamAccessLogsMessage_Identifier::set_log_name(const ::std::string& value) {
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
}
#if LANG_CXX11
inline void StreamAccessLogsMessage_Identifier::set_log_name(::std::string&& value) {
  
  log_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
}
#endif
inline void StreamAccessLogsMessage_Identifier::set_log_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
}
inline void StreamAccessLogsMessage_Identifier::set_log_name(const char* value, size_t size) {
  
  log_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
}
inline ::std::string* StreamAccessLogsMessage_Identifier::mutable_log_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
  return log_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamAccessLogsMessage_Identifier::release_log_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
  
  return log_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamAccessLogsMessage_Identifier::set_allocated_log_name(::std::string* log_name) {
  if (log_name != NULL) {
    
  } else {
    
  }
  log_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier.log_name)
}

// -------------------------------------------------------------------

// StreamAccessLogsMessage_HTTPAccessLogEntries

// repeated .envoy.api.v2.filter.accesslog.HTTPAccessLogEntry log_entry = 1;
inline int StreamAccessLogsMessage_HTTPAccessLogEntries::log_entry_size() const {
  return log_entry_.size();
}
inline void StreamAccessLogsMessage_HTTPAccessLogEntries::clear_log_entry() {
  log_entry_.Clear();
}
inline const ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry& StreamAccessLogsMessage_HTTPAccessLogEntries::log_entry(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries.log_entry)
  return log_entry_.Get(index);
}
inline ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry* StreamAccessLogsMessage_HTTPAccessLogEntries::mutable_log_entry(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries.log_entry)
  return log_entry_.Mutable(index);
}
inline ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry* StreamAccessLogsMessage_HTTPAccessLogEntries::add_log_entry() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries.log_entry)
  return log_entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry >*
StreamAccessLogsMessage_HTTPAccessLogEntries::mutable_log_entry() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries.log_entry)
  return &log_entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry >&
StreamAccessLogsMessage_HTTPAccessLogEntries::log_entry() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries.log_entry)
  return log_entry_;
}

// -------------------------------------------------------------------

// StreamAccessLogsMessage_TCPAccessLogEntries

// repeated .envoy.api.v2.filter.accesslog.TCPAccessLogEntry log_entry = 1;
inline int StreamAccessLogsMessage_TCPAccessLogEntries::log_entry_size() const {
  return log_entry_.size();
}
inline void StreamAccessLogsMessage_TCPAccessLogEntries::clear_log_entry() {
  log_entry_.Clear();
}
inline const ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry& StreamAccessLogsMessage_TCPAccessLogEntries::log_entry(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries.log_entry)
  return log_entry_.Get(index);
}
inline ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry* StreamAccessLogsMessage_TCPAccessLogEntries::mutable_log_entry(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries.log_entry)
  return log_entry_.Mutable(index);
}
inline ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry* StreamAccessLogsMessage_TCPAccessLogEntries::add_log_entry() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries.log_entry)
  return log_entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry >*
StreamAccessLogsMessage_TCPAccessLogEntries::mutable_log_entry() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries.log_entry)
  return &log_entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::accesslog::TCPAccessLogEntry >&
StreamAccessLogsMessage_TCPAccessLogEntries::log_entry() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries.log_entry)
  return log_entry_;
}

// -------------------------------------------------------------------

// StreamAccessLogsMessage

// .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier identifier = 1;
inline bool StreamAccessLogsMessage::has_identifier() const {
  return this != internal_default_instance() && identifier_ != NULL;
}
inline void StreamAccessLogsMessage::clear_identifier() {
  if (GetArenaNoVirtual() == NULL && identifier_ != NULL) {
    delete identifier_;
  }
  identifier_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier& StreamAccessLogsMessage::identifier() const {
  const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* p = identifier_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.identifier)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier*>(
      &::envoy::api::v2::filter::accesslog::_StreamAccessLogsMessage_Identifier_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* StreamAccessLogsMessage::release_identifier() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.identifier)
  
  ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* StreamAccessLogsMessage::mutable_identifier() {
  
  if (identifier_ == NULL) {
    identifier_ = new ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.identifier)
  return identifier_;
}
inline void StreamAccessLogsMessage::set_allocated_identifier(::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_Identifier* identifier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete identifier_;
  }
  if (identifier) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      identifier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    
  } else {
    
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.identifier)
}

// .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries http_logs = 2;
inline bool StreamAccessLogsMessage::has_http_logs() const {
  return log_entries_case() == kHttpLogs;
}
inline void StreamAccessLogsMessage::set_has_http_logs() {
  _oneof_case_[0] = kHttpLogs;
}
inline void StreamAccessLogsMessage::clear_http_logs() {
  if (has_http_logs()) {
    delete log_entries_.http_logs_;
    clear_has_log_entries();
  }
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* StreamAccessLogsMessage::release_http_logs() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.http_logs)
  if (has_http_logs()) {
    clear_has_log_entries();
      ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* temp = log_entries_.http_logs_;
    log_entries_.http_logs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries& StreamAccessLogsMessage::http_logs() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.http_logs)
  return has_http_logs()
      ? *log_entries_.http_logs_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries*>(&::envoy::api::v2::filter::accesslog::_StreamAccessLogsMessage_HTTPAccessLogEntries_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries* StreamAccessLogsMessage::mutable_http_logs() {
  if (!has_http_logs()) {
    clear_log_entries();
    set_has_http_logs();
    log_entries_.http_logs_ = new ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_HTTPAccessLogEntries;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.http_logs)
  return log_entries_.http_logs_;
}

// .envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries tcp_logs = 3;
inline bool StreamAccessLogsMessage::has_tcp_logs() const {
  return log_entries_case() == kTcpLogs;
}
inline void StreamAccessLogsMessage::set_has_tcp_logs() {
  _oneof_case_[0] = kTcpLogs;
}
inline void StreamAccessLogsMessage::clear_tcp_logs() {
  if (has_tcp_logs()) {
    delete log_entries_.tcp_logs_;
    clear_has_log_entries();
  }
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* StreamAccessLogsMessage::release_tcp_logs() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.tcp_logs)
  if (has_tcp_logs()) {
    clear_has_log_entries();
      ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* temp = log_entries_.tcp_logs_;
    log_entries_.tcp_logs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries& StreamAccessLogsMessage::tcp_logs() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.tcp_logs)
  return has_tcp_logs()
      ? *log_entries_.tcp_logs_
      : *reinterpret_cast< ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries*>(&::envoy::api::v2::filter::accesslog::_StreamAccessLogsMessage_TCPAccessLogEntries_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries* StreamAccessLogsMessage::mutable_tcp_logs() {
  if (!has_tcp_logs()) {
    clear_log_entries();
    set_has_tcp_logs();
    log_entries_.tcp_logs_ = new ::envoy::api::v2::filter::accesslog::StreamAccessLogsMessage_TCPAccessLogEntries;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.tcp_logs)
  return log_entries_.tcp_logs_;
}

inline bool StreamAccessLogsMessage::has_log_entries() const {
  return log_entries_case() != LOG_ENTRIES_NOT_SET;
}
inline void StreamAccessLogsMessage::clear_has_log_entries() {
  _oneof_case_[0] = LOG_ENTRIES_NOT_SET;
}
inline StreamAccessLogsMessage::LogEntriesCase StreamAccessLogsMessage::log_entries_case() const {
  return StreamAccessLogsMessage::LogEntriesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamAccessLogsResponse

// -------------------------------------------------------------------

// AccessLog

// string name = 1;
inline void AccessLog::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLog::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLog.name)
  return name_.GetNoArena();
}
inline void AccessLog::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.accesslog.AccessLog.name)
}
#if LANG_CXX11
inline void AccessLog::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.accesslog.AccessLog.name)
}
#endif
inline void AccessLog::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.accesslog.AccessLog.name)
}
inline void AccessLog::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.accesslog.AccessLog.name)
}
inline ::std::string* AccessLog::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLog.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLog::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLog.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLog::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLog.name)
}

// .envoy.api.v2.filter.accesslog.AccessLogFilter filter = 2;
inline bool AccessLog::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void AccessLog::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::envoy::api::v2::filter::accesslog::AccessLogFilter& AccessLog::filter() const {
  const ::envoy::api::v2::filter::accesslog::AccessLogFilter* p = filter_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLog.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::accesslog::AccessLogFilter*>(
      &::envoy::api::v2::filter::accesslog::_AccessLogFilter_default_instance_);
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* AccessLog::release_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLog.filter)
  
  ::envoy::api::v2::filter::accesslog::AccessLogFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::envoy::api::v2::filter::accesslog::AccessLogFilter* AccessLog::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::envoy::api::v2::filter::accesslog::AccessLogFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLog.filter)
  return filter_;
}
inline void AccessLog::set_allocated_filter(::envoy::api::v2::filter::accesslog::AccessLogFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLog.filter)
}

// .google.protobuf.Struct config = 3;
inline bool AccessLog::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline const ::google::protobuf::Struct& AccessLog::config() const {
  const ::google::protobuf::Struct* p = config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.accesslog.AccessLog.config)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* AccessLog::release_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.accesslog.AccessLog.config)
  
  ::google::protobuf::Struct* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* AccessLog::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.accesslog.AccessLog.config)
  return config_;
}
inline void AccessLog::set_allocated_config(::google::protobuf::Struct* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.accesslog.AccessLog.config)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace accesslog
}  // namespace filter
}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion>() {
  return ::envoy::api::v2::filter::accesslog::TLSProperties_TLSVersion_descriptor();
}
template <> struct is_proto_enum< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion>() {
  return ::envoy::api::v2::filter::accesslog::HTTPAccessLogEntry_HTTPVersion_descriptor();
}
template <> struct is_proto_enum< ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op>() {
  return ::envoy::api::v2::filter::accesslog::ComparisonFilter_Op_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2ffilter_2faccesslog_2faccesslog_2eproto__INCLUDED
