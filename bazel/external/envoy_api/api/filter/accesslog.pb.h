// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/filter/accesslog.proto

#ifndef PROTOBUF_api_2ffilter_2faccesslog_2eproto__INCLUDED
#define PROTOBUF_api_2ffilter_2faccesslog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api/base.pb.h"
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_api_2ffilter_2faccesslog_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsComparisonFilterImpl();
void InitDefaultsComparisonFilter();
void InitDefaultsStatusCodeFilterImpl();
void InitDefaultsStatusCodeFilter();
void InitDefaultsDurationFilterImpl();
void InitDefaultsDurationFilter();
void InitDefaultsNotHealthCheckFilterImpl();
void InitDefaultsNotHealthCheckFilter();
void InitDefaultsTraceableFilterImpl();
void InitDefaultsTraceableFilter();
void InitDefaultsRuntimeFilterImpl();
void InitDefaultsRuntimeFilter();
void InitDefaultsAccessLogFilterImpl();
void InitDefaultsAccessLogFilter();
void InitDefaultsFileAccessLogImpl();
void InitDefaultsFileAccessLog();
void InitDefaultsAccessLogImpl();
void InitDefaultsAccessLog();
inline void InitDefaults() {
  InitDefaultsComparisonFilter();
  InitDefaultsStatusCodeFilter();
  InitDefaultsDurationFilter();
  InitDefaultsNotHealthCheckFilter();
  InitDefaultsTraceableFilter();
  InitDefaultsRuntimeFilter();
  InitDefaultsAccessLogFilter();
  InitDefaultsFileAccessLog();
  InitDefaultsAccessLog();
}
}  // namespace protobuf_api_2ffilter_2faccesslog_2eproto
namespace envoy {
namespace api {
namespace v2 {
namespace filter {
class AccessLog;
class AccessLogDefaultTypeInternal;
extern AccessLogDefaultTypeInternal _AccessLog_default_instance_;
class AccessLogFilter;
class AccessLogFilterDefaultTypeInternal;
extern AccessLogFilterDefaultTypeInternal _AccessLogFilter_default_instance_;
class AndFilter;
class AndFilterDefaultTypeInternal;
extern AndFilterDefaultTypeInternal _AndFilter_default_instance_;
class ComparisonFilter;
class ComparisonFilterDefaultTypeInternal;
extern ComparisonFilterDefaultTypeInternal _ComparisonFilter_default_instance_;
class DurationFilter;
class DurationFilterDefaultTypeInternal;
extern DurationFilterDefaultTypeInternal _DurationFilter_default_instance_;
class FileAccessLog;
class FileAccessLogDefaultTypeInternal;
extern FileAccessLogDefaultTypeInternal _FileAccessLog_default_instance_;
class NotHealthCheckFilter;
class NotHealthCheckFilterDefaultTypeInternal;
extern NotHealthCheckFilterDefaultTypeInternal _NotHealthCheckFilter_default_instance_;
class OrFilter;
class OrFilterDefaultTypeInternal;
extern OrFilterDefaultTypeInternal _OrFilter_default_instance_;
class RuntimeFilter;
class RuntimeFilterDefaultTypeInternal;
extern RuntimeFilterDefaultTypeInternal _RuntimeFilter_default_instance_;
class StatusCodeFilter;
class StatusCodeFilterDefaultTypeInternal;
extern StatusCodeFilterDefaultTypeInternal _StatusCodeFilter_default_instance_;
class TraceableFilter;
class TraceableFilterDefaultTypeInternal;
extern TraceableFilterDefaultTypeInternal _TraceableFilter_default_instance_;
}  // namespace filter
}  // namespace v2
}  // namespace api
}  // namespace envoy
namespace envoy {
namespace api {
namespace v2 {
namespace filter {

enum ComparisonFilter_Op {
  ComparisonFilter_Op_EQ = 0,
  ComparisonFilter_Op_GE = 1,
  ComparisonFilter_Op_ComparisonFilter_Op_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ComparisonFilter_Op_ComparisonFilter_Op_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ComparisonFilter_Op_IsValid(int value);
const ComparisonFilter_Op ComparisonFilter_Op_Op_MIN = ComparisonFilter_Op_EQ;
const ComparisonFilter_Op ComparisonFilter_Op_Op_MAX = ComparisonFilter_Op_GE;
const int ComparisonFilter_Op_Op_ARRAYSIZE = ComparisonFilter_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComparisonFilter_Op_descriptor();
inline const ::std::string& ComparisonFilter_Op_Name(ComparisonFilter_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComparisonFilter_Op_descriptor(), value);
}
inline bool ComparisonFilter_Op_Parse(
    const ::std::string& name, ComparisonFilter_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonFilter_Op>(
    ComparisonFilter_Op_descriptor(), name, value);
}
// ===================================================================

class ComparisonFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.ComparisonFilter) */ {
 public:
  ComparisonFilter();
  virtual ~ComparisonFilter();

  ComparisonFilter(const ComparisonFilter& from);

  inline ComparisonFilter& operator=(const ComparisonFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComparisonFilter(ComparisonFilter&& from) noexcept
    : ComparisonFilter() {
    *this = ::std::move(from);
  }

  inline ComparisonFilter& operator=(ComparisonFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ComparisonFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComparisonFilter* internal_default_instance() {
    return reinterpret_cast<const ComparisonFilter*>(
               &_ComparisonFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ComparisonFilter* other);
  friend void swap(ComparisonFilter& a, ComparisonFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComparisonFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  ComparisonFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ComparisonFilter& from);
  void MergeFrom(const ComparisonFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ComparisonFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ComparisonFilter_Op Op;
  static const Op EQ =
    ComparisonFilter_Op_EQ;
  static const Op GE =
    ComparisonFilter_Op_GE;
  static inline bool Op_IsValid(int value) {
    return ComparisonFilter_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ComparisonFilter_Op_Op_MIN;
  static const Op Op_MAX =
    ComparisonFilter_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ComparisonFilter_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ComparisonFilter_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ComparisonFilter_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ComparisonFilter_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .envoy.api.v2.RuntimeUInt32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::envoy::api::v2::RuntimeUInt32& value() const;
  ::envoy::api::v2::RuntimeUInt32* mutable_value();
  ::envoy::api::v2::RuntimeUInt32* release_value();
  void set_allocated_value(::envoy::api::v2::RuntimeUInt32* value);

  // .envoy.api.v2.filter.ComparisonFilter.Op op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::envoy::api::v2::filter::ComparisonFilter_Op op() const;
  void set_op(::envoy::api::v2::filter::ComparisonFilter_Op value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.ComparisonFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::RuntimeUInt32* value_;
  int op_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsComparisonFilterImpl();
};
// -------------------------------------------------------------------

class StatusCodeFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.StatusCodeFilter) */ {
 public:
  StatusCodeFilter();
  virtual ~StatusCodeFilter();

  StatusCodeFilter(const StatusCodeFilter& from);

  inline StatusCodeFilter& operator=(const StatusCodeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusCodeFilter(StatusCodeFilter&& from) noexcept
    : StatusCodeFilter() {
    *this = ::std::move(from);
  }

  inline StatusCodeFilter& operator=(StatusCodeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusCodeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusCodeFilter* internal_default_instance() {
    return reinterpret_cast<const StatusCodeFilter*>(
               &_StatusCodeFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(StatusCodeFilter* other);
  friend void swap(StatusCodeFilter& a, StatusCodeFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusCodeFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusCodeFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusCodeFilter& from);
  void MergeFrom(const StatusCodeFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusCodeFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.ComparisonFilter comparison = 1;
  bool has_comparison() const;
  void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  const ::envoy::api::v2::filter::ComparisonFilter& comparison() const;
  ::envoy::api::v2::filter::ComparisonFilter* mutable_comparison();
  ::envoy::api::v2::filter::ComparisonFilter* release_comparison();
  void set_allocated_comparison(::envoy::api::v2::filter::ComparisonFilter* comparison);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.StatusCodeFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::ComparisonFilter* comparison_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsStatusCodeFilterImpl();
};
// -------------------------------------------------------------------

class DurationFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.DurationFilter) */ {
 public:
  DurationFilter();
  virtual ~DurationFilter();

  DurationFilter(const DurationFilter& from);

  inline DurationFilter& operator=(const DurationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DurationFilter(DurationFilter&& from) noexcept
    : DurationFilter() {
    *this = ::std::move(from);
  }

  inline DurationFilter& operator=(DurationFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DurationFilter* internal_default_instance() {
    return reinterpret_cast<const DurationFilter*>(
               &_DurationFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DurationFilter* other);
  friend void swap(DurationFilter& a, DurationFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DurationFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  DurationFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DurationFilter& from);
  void MergeFrom(const DurationFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DurationFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.ComparisonFilter comparison = 1;
  bool has_comparison() const;
  void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  const ::envoy::api::v2::filter::ComparisonFilter& comparison() const;
  ::envoy::api::v2::filter::ComparisonFilter* mutable_comparison();
  ::envoy::api::v2::filter::ComparisonFilter* release_comparison();
  void set_allocated_comparison(::envoy::api::v2::filter::ComparisonFilter* comparison);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.DurationFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::filter::ComparisonFilter* comparison_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsDurationFilterImpl();
};
// -------------------------------------------------------------------

class NotHealthCheckFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.NotHealthCheckFilter) */ {
 public:
  NotHealthCheckFilter();
  virtual ~NotHealthCheckFilter();

  NotHealthCheckFilter(const NotHealthCheckFilter& from);

  inline NotHealthCheckFilter& operator=(const NotHealthCheckFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotHealthCheckFilter(NotHealthCheckFilter&& from) noexcept
    : NotHealthCheckFilter() {
    *this = ::std::move(from);
  }

  inline NotHealthCheckFilter& operator=(NotHealthCheckFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotHealthCheckFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotHealthCheckFilter* internal_default_instance() {
    return reinterpret_cast<const NotHealthCheckFilter*>(
               &_NotHealthCheckFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NotHealthCheckFilter* other);
  friend void swap(NotHealthCheckFilter& a, NotHealthCheckFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotHealthCheckFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  NotHealthCheckFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NotHealthCheckFilter& from);
  void MergeFrom(const NotHealthCheckFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NotHealthCheckFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.NotHealthCheckFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsNotHealthCheckFilterImpl();
};
// -------------------------------------------------------------------

class TraceableFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.TraceableFilter) */ {
 public:
  TraceableFilter();
  virtual ~TraceableFilter();

  TraceableFilter(const TraceableFilter& from);

  inline TraceableFilter& operator=(const TraceableFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TraceableFilter(TraceableFilter&& from) noexcept
    : TraceableFilter() {
    *this = ::std::move(from);
  }

  inline TraceableFilter& operator=(TraceableFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceableFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TraceableFilter* internal_default_instance() {
    return reinterpret_cast<const TraceableFilter*>(
               &_TraceableFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TraceableFilter* other);
  friend void swap(TraceableFilter& a, TraceableFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TraceableFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  TraceableFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TraceableFilter& from);
  void MergeFrom(const TraceableFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TraceableFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.TraceableFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsTraceableFilterImpl();
};
// -------------------------------------------------------------------

class RuntimeFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.RuntimeFilter) */ {
 public:
  RuntimeFilter();
  virtual ~RuntimeFilter();

  RuntimeFilter(const RuntimeFilter& from);

  inline RuntimeFilter& operator=(const RuntimeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeFilter(RuntimeFilter&& from) noexcept
    : RuntimeFilter() {
    *this = ::std::move(from);
  }

  inline RuntimeFilter& operator=(RuntimeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeFilter* internal_default_instance() {
    return reinterpret_cast<const RuntimeFilter*>(
               &_RuntimeFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RuntimeFilter* other);
  friend void swap(RuntimeFilter& a, RuntimeFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeFilter& from);
  void MergeFrom(const RuntimeFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string runtime_key = 1;
  void clear_runtime_key();
  static const int kRuntimeKeyFieldNumber = 1;
  const ::std::string& runtime_key() const;
  void set_runtime_key(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_key(::std::string&& value);
  #endif
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  ::std::string* mutable_runtime_key();
  ::std::string* release_runtime_key();
  void set_allocated_runtime_key(::std::string* runtime_key);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.RuntimeFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr runtime_key_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsRuntimeFilterImpl();
};
// -------------------------------------------------------------------

class AndFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.AndFilter) */ {
 public:
  AndFilter();
  virtual ~AndFilter();

  AndFilter(const AndFilter& from);

  inline AndFilter& operator=(const AndFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AndFilter(AndFilter&& from) noexcept
    : AndFilter() {
    *this = ::std::move(from);
  }

  inline AndFilter& operator=(AndFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AndFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AndFilter* internal_default_instance() {
    return reinterpret_cast<const AndFilter*>(
               &_AndFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AndFilter* other);
  friend void swap(AndFilter& a, AndFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AndFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  AndFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndFilter& from);
  void MergeFrom(const AndFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.AccessLogFilter filters = 1;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  const ::envoy::api::v2::filter::AccessLogFilter& filters(int index) const;
  ::envoy::api::v2::filter::AccessLogFilter* mutable_filters(int index);
  ::envoy::api::v2::filter::AccessLogFilter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.AndFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter > filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class OrFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.OrFilter) */ {
 public:
  OrFilter();
  virtual ~OrFilter();

  OrFilter(const OrFilter& from);

  inline OrFilter& operator=(const OrFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrFilter(OrFilter&& from) noexcept
    : OrFilter() {
    *this = ::std::move(from);
  }

  inline OrFilter& operator=(OrFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrFilter* internal_default_instance() {
    return reinterpret_cast<const OrFilter*>(
               &_OrFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(OrFilter* other);
  friend void swap(OrFilter& a, OrFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  OrFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OrFilter& from);
  void MergeFrom(const OrFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OrFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.filter.AccessLogFilter filters = 2;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  const ::envoy::api::v2::filter::AccessLogFilter& filters(int index) const;
  ::envoy::api::v2::filter::AccessLogFilter* mutable_filters(int index);
  ::envoy::api::v2::filter::AccessLogFilter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.OrFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter > filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class AccessLogFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.AccessLogFilter) */ {
 public:
  AccessLogFilter();
  virtual ~AccessLogFilter();

  AccessLogFilter(const AccessLogFilter& from);

  inline AccessLogFilter& operator=(const AccessLogFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLogFilter(AccessLogFilter&& from) noexcept
    : AccessLogFilter() {
    *this = ::std::move(from);
  }

  inline AccessLogFilter& operator=(AccessLogFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLogFilter& default_instance();

  enum FilterSpecifierCase {
    kStatusCodeFilter = 1,
    kDurationFilter = 2,
    kNotHealthCheckFilter = 3,
    kTraceableFilter = 4,
    kRuntimeFilter = 5,
    kAndFilter = 6,
    kOrFilter = 7,
    FILTER_SPECIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLogFilter* internal_default_instance() {
    return reinterpret_cast<const AccessLogFilter*>(
               &_AccessLogFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AccessLogFilter* other);
  friend void swap(AccessLogFilter& a, AccessLogFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLogFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLogFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLogFilter& from);
  void MergeFrom(const AccessLogFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLogFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.filter.StatusCodeFilter status_code_filter = 1;
  bool has_status_code_filter() const;
  void clear_status_code_filter();
  static const int kStatusCodeFilterFieldNumber = 1;
  const ::envoy::api::v2::filter::StatusCodeFilter& status_code_filter() const;
  ::envoy::api::v2::filter::StatusCodeFilter* mutable_status_code_filter();
  ::envoy::api::v2::filter::StatusCodeFilter* release_status_code_filter();
  void set_allocated_status_code_filter(::envoy::api::v2::filter::StatusCodeFilter* status_code_filter);

  // .envoy.api.v2.filter.DurationFilter duration_filter = 2;
  bool has_duration_filter() const;
  void clear_duration_filter();
  static const int kDurationFilterFieldNumber = 2;
  const ::envoy::api::v2::filter::DurationFilter& duration_filter() const;
  ::envoy::api::v2::filter::DurationFilter* mutable_duration_filter();
  ::envoy::api::v2::filter::DurationFilter* release_duration_filter();
  void set_allocated_duration_filter(::envoy::api::v2::filter::DurationFilter* duration_filter);

  // .envoy.api.v2.filter.NotHealthCheckFilter not_health_check_filter = 3;
  bool has_not_health_check_filter() const;
  void clear_not_health_check_filter();
  static const int kNotHealthCheckFilterFieldNumber = 3;
  const ::envoy::api::v2::filter::NotHealthCheckFilter& not_health_check_filter() const;
  ::envoy::api::v2::filter::NotHealthCheckFilter* mutable_not_health_check_filter();
  ::envoy::api::v2::filter::NotHealthCheckFilter* release_not_health_check_filter();
  void set_allocated_not_health_check_filter(::envoy::api::v2::filter::NotHealthCheckFilter* not_health_check_filter);

  // .envoy.api.v2.filter.TraceableFilter traceable_filter = 4;
  bool has_traceable_filter() const;
  void clear_traceable_filter();
  static const int kTraceableFilterFieldNumber = 4;
  const ::envoy::api::v2::filter::TraceableFilter& traceable_filter() const;
  ::envoy::api::v2::filter::TraceableFilter* mutable_traceable_filter();
  ::envoy::api::v2::filter::TraceableFilter* release_traceable_filter();
  void set_allocated_traceable_filter(::envoy::api::v2::filter::TraceableFilter* traceable_filter);

  // .envoy.api.v2.filter.RuntimeFilter runtime_filter = 5;
  bool has_runtime_filter() const;
  void clear_runtime_filter();
  static const int kRuntimeFilterFieldNumber = 5;
  const ::envoy::api::v2::filter::RuntimeFilter& runtime_filter() const;
  ::envoy::api::v2::filter::RuntimeFilter* mutable_runtime_filter();
  ::envoy::api::v2::filter::RuntimeFilter* release_runtime_filter();
  void set_allocated_runtime_filter(::envoy::api::v2::filter::RuntimeFilter* runtime_filter);

  // .envoy.api.v2.filter.AndFilter and_filter = 6;
  bool has_and_filter() const;
  void clear_and_filter();
  static const int kAndFilterFieldNumber = 6;
  const ::envoy::api::v2::filter::AndFilter& and_filter() const;
  ::envoy::api::v2::filter::AndFilter* mutable_and_filter();
  ::envoy::api::v2::filter::AndFilter* release_and_filter();
  void set_allocated_and_filter(::envoy::api::v2::filter::AndFilter* and_filter);

  // .envoy.api.v2.filter.OrFilter or_filter = 7;
  bool has_or_filter() const;
  void clear_or_filter();
  static const int kOrFilterFieldNumber = 7;
  const ::envoy::api::v2::filter::OrFilter& or_filter() const;
  ::envoy::api::v2::filter::OrFilter* mutable_or_filter();
  ::envoy::api::v2::filter::OrFilter* release_or_filter();
  void set_allocated_or_filter(::envoy::api::v2::filter::OrFilter* or_filter);

  FilterSpecifierCase filter_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.AccessLogFilter)
 private:
  void set_has_status_code_filter();
  void set_has_duration_filter();
  void set_has_not_health_check_filter();
  void set_has_traceable_filter();
  void set_has_runtime_filter();
  void set_has_and_filter();
  void set_has_or_filter();

  inline bool has_filter_specifier() const;
  void clear_filter_specifier();
  inline void clear_has_filter_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union FilterSpecifierUnion {
    FilterSpecifierUnion() {}
    ::envoy::api::v2::filter::StatusCodeFilter* status_code_filter_;
    ::envoy::api::v2::filter::DurationFilter* duration_filter_;
    ::envoy::api::v2::filter::NotHealthCheckFilter* not_health_check_filter_;
    ::envoy::api::v2::filter::TraceableFilter* traceable_filter_;
    ::envoy::api::v2::filter::RuntimeFilter* runtime_filter_;
    ::envoy::api::v2::filter::AndFilter* and_filter_;
    ::envoy::api::v2::filter::OrFilter* or_filter_;
  } filter_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsAccessLogFilterImpl();
};
// -------------------------------------------------------------------

class FileAccessLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.FileAccessLog) */ {
 public:
  FileAccessLog();
  virtual ~FileAccessLog();

  FileAccessLog(const FileAccessLog& from);

  inline FileAccessLog& operator=(const FileAccessLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileAccessLog(FileAccessLog&& from) noexcept
    : FileAccessLog() {
    *this = ::std::move(from);
  }

  inline FileAccessLog& operator=(FileAccessLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileAccessLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileAccessLog* internal_default_instance() {
    return reinterpret_cast<const FileAccessLog*>(
               &_FileAccessLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(FileAccessLog* other);
  friend void swap(FileAccessLog& a, FileAccessLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileAccessLog* New() const PROTOBUF_FINAL { return New(NULL); }

  FileAccessLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileAccessLog& from);
  void MergeFrom(const FileAccessLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileAccessLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.FileAccessLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsFileAccessLogImpl();
};
// -------------------------------------------------------------------

class AccessLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.filter.AccessLog) */ {
 public:
  AccessLog();
  virtual ~AccessLog();

  AccessLog(const AccessLog& from);

  inline AccessLog& operator=(const AccessLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLog(AccessLog&& from) noexcept
    : AccessLog() {
    *this = ::std::move(from);
  }

  inline AccessLog& operator=(AccessLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLog* internal_default_instance() {
    return reinterpret_cast<const AccessLog*>(
               &_AccessLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AccessLog* other);
  friend void swap(AccessLog& a, AccessLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLog* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccessLog& from);
  void MergeFrom(const AccessLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .envoy.api.v2.filter.AccessLogFilter filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  const ::envoy::api::v2::filter::AccessLogFilter& filter() const;
  ::envoy::api::v2::filter::AccessLogFilter* mutable_filter();
  ::envoy::api::v2::filter::AccessLogFilter* release_filter();
  void set_allocated_filter(::envoy::api::v2::filter::AccessLogFilter* filter);

  // .google.protobuf.Struct config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::google::protobuf::Struct& config() const;
  ::google::protobuf::Struct* mutable_config();
  ::google::protobuf::Struct* release_config();
  void set_allocated_config(::google::protobuf::Struct* config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.filter.AccessLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::envoy::api::v2::filter::AccessLogFilter* filter_;
  ::google::protobuf::Struct* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2ffilter_2faccesslog_2eproto::TableStruct;
  friend void ::protobuf_api_2ffilter_2faccesslog_2eproto::InitDefaultsAccessLogImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ComparisonFilter

// .envoy.api.v2.filter.ComparisonFilter.Op op = 1;
inline void ComparisonFilter::clear_op() {
  op_ = 0;
}
inline ::envoy::api::v2::filter::ComparisonFilter_Op ComparisonFilter::op() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.ComparisonFilter.op)
  return static_cast< ::envoy::api::v2::filter::ComparisonFilter_Op >(op_);
}
inline void ComparisonFilter::set_op(::envoy::api::v2::filter::ComparisonFilter_Op value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.ComparisonFilter.op)
}

// .envoy.api.v2.RuntimeUInt32 value = 2;
inline bool ComparisonFilter::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void ComparisonFilter::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::envoy::api::v2::RuntimeUInt32& ComparisonFilter::value() const {
  const ::envoy::api::v2::RuntimeUInt32* p = value_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.ComparisonFilter.value)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RuntimeUInt32*>(
      &::envoy::api::v2::_RuntimeUInt32_default_instance_);
}
inline ::envoy::api::v2::RuntimeUInt32* ComparisonFilter::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::envoy::api::v2::RuntimeUInt32;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.ComparisonFilter.value)
  return value_;
}
inline ::envoy::api::v2::RuntimeUInt32* ComparisonFilter::release_value() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.ComparisonFilter.value)
  
  ::envoy::api::v2::RuntimeUInt32* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ComparisonFilter::set_allocated_value(::envoy::api::v2::RuntimeUInt32* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.ComparisonFilter.value)
}

// -------------------------------------------------------------------

// StatusCodeFilter

// .envoy.api.v2.filter.ComparisonFilter comparison = 1;
inline bool StatusCodeFilter::has_comparison() const {
  return this != internal_default_instance() && comparison_ != NULL;
}
inline void StatusCodeFilter::clear_comparison() {
  if (GetArenaNoVirtual() == NULL && comparison_ != NULL) delete comparison_;
  comparison_ = NULL;
}
inline const ::envoy::api::v2::filter::ComparisonFilter& StatusCodeFilter::comparison() const {
  const ::envoy::api::v2::filter::ComparisonFilter* p = comparison_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.StatusCodeFilter.comparison)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::ComparisonFilter*>(
      &::envoy::api::v2::filter::_ComparisonFilter_default_instance_);
}
inline ::envoy::api::v2::filter::ComparisonFilter* StatusCodeFilter::mutable_comparison() {
  
  if (comparison_ == NULL) {
    comparison_ = new ::envoy::api::v2::filter::ComparisonFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.StatusCodeFilter.comparison)
  return comparison_;
}
inline ::envoy::api::v2::filter::ComparisonFilter* StatusCodeFilter::release_comparison() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.StatusCodeFilter.comparison)
  
  ::envoy::api::v2::filter::ComparisonFilter* temp = comparison_;
  comparison_ = NULL;
  return temp;
}
inline void StatusCodeFilter::set_allocated_comparison(::envoy::api::v2::filter::ComparisonFilter* comparison) {
  delete comparison_;
  comparison_ = comparison;
  if (comparison) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.StatusCodeFilter.comparison)
}

// -------------------------------------------------------------------

// DurationFilter

// .envoy.api.v2.filter.ComparisonFilter comparison = 1;
inline bool DurationFilter::has_comparison() const {
  return this != internal_default_instance() && comparison_ != NULL;
}
inline void DurationFilter::clear_comparison() {
  if (GetArenaNoVirtual() == NULL && comparison_ != NULL) delete comparison_;
  comparison_ = NULL;
}
inline const ::envoy::api::v2::filter::ComparisonFilter& DurationFilter::comparison() const {
  const ::envoy::api::v2::filter::ComparisonFilter* p = comparison_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.DurationFilter.comparison)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::ComparisonFilter*>(
      &::envoy::api::v2::filter::_ComparisonFilter_default_instance_);
}
inline ::envoy::api::v2::filter::ComparisonFilter* DurationFilter::mutable_comparison() {
  
  if (comparison_ == NULL) {
    comparison_ = new ::envoy::api::v2::filter::ComparisonFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.DurationFilter.comparison)
  return comparison_;
}
inline ::envoy::api::v2::filter::ComparisonFilter* DurationFilter::release_comparison() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.DurationFilter.comparison)
  
  ::envoy::api::v2::filter::ComparisonFilter* temp = comparison_;
  comparison_ = NULL;
  return temp;
}
inline void DurationFilter::set_allocated_comparison(::envoy::api::v2::filter::ComparisonFilter* comparison) {
  delete comparison_;
  comparison_ = comparison;
  if (comparison) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.DurationFilter.comparison)
}

// -------------------------------------------------------------------

// NotHealthCheckFilter

// -------------------------------------------------------------------

// TraceableFilter

// -------------------------------------------------------------------

// RuntimeFilter

// string runtime_key = 1;
inline void RuntimeFilter::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeFilter::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.RuntimeFilter.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RuntimeFilter::set_runtime_key(const ::std::string& value) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.RuntimeFilter.runtime_key)
}
#if LANG_CXX11
inline void RuntimeFilter::set_runtime_key(::std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.RuntimeFilter.runtime_key)
}
#endif
inline void RuntimeFilter::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.RuntimeFilter.runtime_key)
}
inline void RuntimeFilter::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.RuntimeFilter.runtime_key)
}
inline ::std::string* RuntimeFilter::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.RuntimeFilter.runtime_key)
  return runtime_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeFilter::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.RuntimeFilter.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeFilter::set_allocated_runtime_key(::std::string* runtime_key) {
  if (runtime_key != NULL) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.RuntimeFilter.runtime_key)
}

// -------------------------------------------------------------------

// AndFilter

// repeated .envoy.api.v2.filter.AccessLogFilter filters = 1;
inline int AndFilter::filters_size() const {
  return filters_.size();
}
inline void AndFilter::clear_filters() {
  filters_.Clear();
}
inline const ::envoy::api::v2::filter::AccessLogFilter& AndFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AndFilter.filters)
  return filters_.Get(index);
}
inline ::envoy::api::v2::filter::AccessLogFilter* AndFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AndFilter.filters)
  return filters_.Mutable(index);
}
inline ::envoy::api::v2::filter::AccessLogFilter* AndFilter::add_filters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.AndFilter.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >*
AndFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.AndFilter.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >&
AndFilter::filters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.AndFilter.filters)
  return filters_;
}

// -------------------------------------------------------------------

// OrFilter

// repeated .envoy.api.v2.filter.AccessLogFilter filters = 2;
inline int OrFilter::filters_size() const {
  return filters_.size();
}
inline void OrFilter::clear_filters() {
  filters_.Clear();
}
inline const ::envoy::api::v2::filter::AccessLogFilter& OrFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.OrFilter.filters)
  return filters_.Get(index);
}
inline ::envoy::api::v2::filter::AccessLogFilter* OrFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.OrFilter.filters)
  return filters_.Mutable(index);
}
inline ::envoy::api::v2::filter::AccessLogFilter* OrFilter::add_filters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.filter.OrFilter.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >*
OrFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.filter.OrFilter.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::filter::AccessLogFilter >&
OrFilter::filters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.filter.OrFilter.filters)
  return filters_;
}

// -------------------------------------------------------------------

// AccessLogFilter

// .envoy.api.v2.filter.StatusCodeFilter status_code_filter = 1;
inline bool AccessLogFilter::has_status_code_filter() const {
  return filter_specifier_case() == kStatusCodeFilter;
}
inline void AccessLogFilter::set_has_status_code_filter() {
  _oneof_case_[0] = kStatusCodeFilter;
}
inline void AccessLogFilter::clear_status_code_filter() {
  if (has_status_code_filter()) {
    delete filter_specifier_.status_code_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::StatusCodeFilter& AccessLogFilter::status_code_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.status_code_filter)
  return has_status_code_filter()
      ? *filter_specifier_.status_code_filter_
      : ::envoy::api::v2::filter::StatusCodeFilter::default_instance();
}
inline ::envoy::api::v2::filter::StatusCodeFilter* AccessLogFilter::mutable_status_code_filter() {
  if (!has_status_code_filter()) {
    clear_filter_specifier();
    set_has_status_code_filter();
    filter_specifier_.status_code_filter_ = new ::envoy::api::v2::filter::StatusCodeFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.status_code_filter)
  return filter_specifier_.status_code_filter_;
}
inline ::envoy::api::v2::filter::StatusCodeFilter* AccessLogFilter::release_status_code_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.status_code_filter)
  if (has_status_code_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::StatusCodeFilter* temp = filter_specifier_.status_code_filter_;
    filter_specifier_.status_code_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_status_code_filter(::envoy::api::v2::filter::StatusCodeFilter* status_code_filter) {
  clear_filter_specifier();
  if (status_code_filter) {
    set_has_status_code_filter();
    filter_specifier_.status_code_filter_ = status_code_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.status_code_filter)
}

// .envoy.api.v2.filter.DurationFilter duration_filter = 2;
inline bool AccessLogFilter::has_duration_filter() const {
  return filter_specifier_case() == kDurationFilter;
}
inline void AccessLogFilter::set_has_duration_filter() {
  _oneof_case_[0] = kDurationFilter;
}
inline void AccessLogFilter::clear_duration_filter() {
  if (has_duration_filter()) {
    delete filter_specifier_.duration_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::DurationFilter& AccessLogFilter::duration_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.duration_filter)
  return has_duration_filter()
      ? *filter_specifier_.duration_filter_
      : ::envoy::api::v2::filter::DurationFilter::default_instance();
}
inline ::envoy::api::v2::filter::DurationFilter* AccessLogFilter::mutable_duration_filter() {
  if (!has_duration_filter()) {
    clear_filter_specifier();
    set_has_duration_filter();
    filter_specifier_.duration_filter_ = new ::envoy::api::v2::filter::DurationFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.duration_filter)
  return filter_specifier_.duration_filter_;
}
inline ::envoy::api::v2::filter::DurationFilter* AccessLogFilter::release_duration_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.duration_filter)
  if (has_duration_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::DurationFilter* temp = filter_specifier_.duration_filter_;
    filter_specifier_.duration_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_duration_filter(::envoy::api::v2::filter::DurationFilter* duration_filter) {
  clear_filter_specifier();
  if (duration_filter) {
    set_has_duration_filter();
    filter_specifier_.duration_filter_ = duration_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.duration_filter)
}

// .envoy.api.v2.filter.NotHealthCheckFilter not_health_check_filter = 3;
inline bool AccessLogFilter::has_not_health_check_filter() const {
  return filter_specifier_case() == kNotHealthCheckFilter;
}
inline void AccessLogFilter::set_has_not_health_check_filter() {
  _oneof_case_[0] = kNotHealthCheckFilter;
}
inline void AccessLogFilter::clear_not_health_check_filter() {
  if (has_not_health_check_filter()) {
    delete filter_specifier_.not_health_check_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::NotHealthCheckFilter& AccessLogFilter::not_health_check_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.not_health_check_filter)
  return has_not_health_check_filter()
      ? *filter_specifier_.not_health_check_filter_
      : ::envoy::api::v2::filter::NotHealthCheckFilter::default_instance();
}
inline ::envoy::api::v2::filter::NotHealthCheckFilter* AccessLogFilter::mutable_not_health_check_filter() {
  if (!has_not_health_check_filter()) {
    clear_filter_specifier();
    set_has_not_health_check_filter();
    filter_specifier_.not_health_check_filter_ = new ::envoy::api::v2::filter::NotHealthCheckFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.not_health_check_filter)
  return filter_specifier_.not_health_check_filter_;
}
inline ::envoy::api::v2::filter::NotHealthCheckFilter* AccessLogFilter::release_not_health_check_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.not_health_check_filter)
  if (has_not_health_check_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::NotHealthCheckFilter* temp = filter_specifier_.not_health_check_filter_;
    filter_specifier_.not_health_check_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_not_health_check_filter(::envoy::api::v2::filter::NotHealthCheckFilter* not_health_check_filter) {
  clear_filter_specifier();
  if (not_health_check_filter) {
    set_has_not_health_check_filter();
    filter_specifier_.not_health_check_filter_ = not_health_check_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.not_health_check_filter)
}

// .envoy.api.v2.filter.TraceableFilter traceable_filter = 4;
inline bool AccessLogFilter::has_traceable_filter() const {
  return filter_specifier_case() == kTraceableFilter;
}
inline void AccessLogFilter::set_has_traceable_filter() {
  _oneof_case_[0] = kTraceableFilter;
}
inline void AccessLogFilter::clear_traceable_filter() {
  if (has_traceable_filter()) {
    delete filter_specifier_.traceable_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::TraceableFilter& AccessLogFilter::traceable_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.traceable_filter)
  return has_traceable_filter()
      ? *filter_specifier_.traceable_filter_
      : ::envoy::api::v2::filter::TraceableFilter::default_instance();
}
inline ::envoy::api::v2::filter::TraceableFilter* AccessLogFilter::mutable_traceable_filter() {
  if (!has_traceable_filter()) {
    clear_filter_specifier();
    set_has_traceable_filter();
    filter_specifier_.traceable_filter_ = new ::envoy::api::v2::filter::TraceableFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.traceable_filter)
  return filter_specifier_.traceable_filter_;
}
inline ::envoy::api::v2::filter::TraceableFilter* AccessLogFilter::release_traceable_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.traceable_filter)
  if (has_traceable_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::TraceableFilter* temp = filter_specifier_.traceable_filter_;
    filter_specifier_.traceable_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_traceable_filter(::envoy::api::v2::filter::TraceableFilter* traceable_filter) {
  clear_filter_specifier();
  if (traceable_filter) {
    set_has_traceable_filter();
    filter_specifier_.traceable_filter_ = traceable_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.traceable_filter)
}

// .envoy.api.v2.filter.RuntimeFilter runtime_filter = 5;
inline bool AccessLogFilter::has_runtime_filter() const {
  return filter_specifier_case() == kRuntimeFilter;
}
inline void AccessLogFilter::set_has_runtime_filter() {
  _oneof_case_[0] = kRuntimeFilter;
}
inline void AccessLogFilter::clear_runtime_filter() {
  if (has_runtime_filter()) {
    delete filter_specifier_.runtime_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::RuntimeFilter& AccessLogFilter::runtime_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.runtime_filter)
  return has_runtime_filter()
      ? *filter_specifier_.runtime_filter_
      : ::envoy::api::v2::filter::RuntimeFilter::default_instance();
}
inline ::envoy::api::v2::filter::RuntimeFilter* AccessLogFilter::mutable_runtime_filter() {
  if (!has_runtime_filter()) {
    clear_filter_specifier();
    set_has_runtime_filter();
    filter_specifier_.runtime_filter_ = new ::envoy::api::v2::filter::RuntimeFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.runtime_filter)
  return filter_specifier_.runtime_filter_;
}
inline ::envoy::api::v2::filter::RuntimeFilter* AccessLogFilter::release_runtime_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.runtime_filter)
  if (has_runtime_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::RuntimeFilter* temp = filter_specifier_.runtime_filter_;
    filter_specifier_.runtime_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_runtime_filter(::envoy::api::v2::filter::RuntimeFilter* runtime_filter) {
  clear_filter_specifier();
  if (runtime_filter) {
    set_has_runtime_filter();
    filter_specifier_.runtime_filter_ = runtime_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.runtime_filter)
}

// .envoy.api.v2.filter.AndFilter and_filter = 6;
inline bool AccessLogFilter::has_and_filter() const {
  return filter_specifier_case() == kAndFilter;
}
inline void AccessLogFilter::set_has_and_filter() {
  _oneof_case_[0] = kAndFilter;
}
inline void AccessLogFilter::clear_and_filter() {
  if (has_and_filter()) {
    delete filter_specifier_.and_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::AndFilter& AccessLogFilter::and_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.and_filter)
  return has_and_filter()
      ? *filter_specifier_.and_filter_
      : ::envoy::api::v2::filter::AndFilter::default_instance();
}
inline ::envoy::api::v2::filter::AndFilter* AccessLogFilter::mutable_and_filter() {
  if (!has_and_filter()) {
    clear_filter_specifier();
    set_has_and_filter();
    filter_specifier_.and_filter_ = new ::envoy::api::v2::filter::AndFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.and_filter)
  return filter_specifier_.and_filter_;
}
inline ::envoy::api::v2::filter::AndFilter* AccessLogFilter::release_and_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.and_filter)
  if (has_and_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::AndFilter* temp = filter_specifier_.and_filter_;
    filter_specifier_.and_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_and_filter(::envoy::api::v2::filter::AndFilter* and_filter) {
  clear_filter_specifier();
  if (and_filter) {
    set_has_and_filter();
    filter_specifier_.and_filter_ = and_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.and_filter)
}

// .envoy.api.v2.filter.OrFilter or_filter = 7;
inline bool AccessLogFilter::has_or_filter() const {
  return filter_specifier_case() == kOrFilter;
}
inline void AccessLogFilter::set_has_or_filter() {
  _oneof_case_[0] = kOrFilter;
}
inline void AccessLogFilter::clear_or_filter() {
  if (has_or_filter()) {
    delete filter_specifier_.or_filter_;
    clear_has_filter_specifier();
  }
}
inline  const ::envoy::api::v2::filter::OrFilter& AccessLogFilter::or_filter() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLogFilter.or_filter)
  return has_or_filter()
      ? *filter_specifier_.or_filter_
      : ::envoy::api::v2::filter::OrFilter::default_instance();
}
inline ::envoy::api::v2::filter::OrFilter* AccessLogFilter::mutable_or_filter() {
  if (!has_or_filter()) {
    clear_filter_specifier();
    set_has_or_filter();
    filter_specifier_.or_filter_ = new ::envoy::api::v2::filter::OrFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLogFilter.or_filter)
  return filter_specifier_.or_filter_;
}
inline ::envoy::api::v2::filter::OrFilter* AccessLogFilter::release_or_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLogFilter.or_filter)
  if (has_or_filter()) {
    clear_has_filter_specifier();
    ::envoy::api::v2::filter::OrFilter* temp = filter_specifier_.or_filter_;
    filter_specifier_.or_filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AccessLogFilter::set_allocated_or_filter(::envoy::api::v2::filter::OrFilter* or_filter) {
  clear_filter_specifier();
  if (or_filter) {
    set_has_or_filter();
    filter_specifier_.or_filter_ = or_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLogFilter.or_filter)
}

inline bool AccessLogFilter::has_filter_specifier() const {
  return filter_specifier_case() != FILTER_SPECIFIER_NOT_SET;
}
inline void AccessLogFilter::clear_has_filter_specifier() {
  _oneof_case_[0] = FILTER_SPECIFIER_NOT_SET;
}
inline AccessLogFilter::FilterSpecifierCase AccessLogFilter::filter_specifier_case() const {
  return AccessLogFilter::FilterSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileAccessLog

// string path = 1;
inline void FileAccessLog::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileAccessLog::path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.FileAccessLog.path)
  return path_.GetNoArena();
}
inline void FileAccessLog::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.FileAccessLog.path)
}
#if LANG_CXX11
inline void FileAccessLog::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.FileAccessLog.path)
}
#endif
inline void FileAccessLog::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.FileAccessLog.path)
}
inline void FileAccessLog::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.FileAccessLog.path)
}
inline ::std::string* FileAccessLog::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.FileAccessLog.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileAccessLog::release_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.FileAccessLog.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileAccessLog::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.FileAccessLog.path)
}

// string format = 2;
inline void FileAccessLog::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileAccessLog::format() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.FileAccessLog.format)
  return format_.GetNoArena();
}
inline void FileAccessLog::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.FileAccessLog.format)
}
#if LANG_CXX11
inline void FileAccessLog::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.FileAccessLog.format)
}
#endif
inline void FileAccessLog::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.FileAccessLog.format)
}
inline void FileAccessLog::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.FileAccessLog.format)
}
inline ::std::string* FileAccessLog::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.FileAccessLog.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileAccessLog::release_format() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.FileAccessLog.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileAccessLog::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.FileAccessLog.format)
}

// -------------------------------------------------------------------

// AccessLog

// string name = 1;
inline void AccessLog::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLog::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLog.name)
  return name_.GetNoArena();
}
inline void AccessLog::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.filter.AccessLog.name)
}
#if LANG_CXX11
inline void AccessLog::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.filter.AccessLog.name)
}
#endif
inline void AccessLog::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.filter.AccessLog.name)
}
inline void AccessLog::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.filter.AccessLog.name)
}
inline ::std::string* AccessLog::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLog.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLog::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLog.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLog::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLog.name)
}

// .envoy.api.v2.filter.AccessLogFilter filter = 2;
inline bool AccessLog::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void AccessLog::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) delete filter_;
  filter_ = NULL;
}
inline const ::envoy::api::v2::filter::AccessLogFilter& AccessLog::filter() const {
  const ::envoy::api::v2::filter::AccessLogFilter* p = filter_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLog.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::filter::AccessLogFilter*>(
      &::envoy::api::v2::filter::_AccessLogFilter_default_instance_);
}
inline ::envoy::api::v2::filter::AccessLogFilter* AccessLog::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::envoy::api::v2::filter::AccessLogFilter;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLog.filter)
  return filter_;
}
inline ::envoy::api::v2::filter::AccessLogFilter* AccessLog::release_filter() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLog.filter)
  
  ::envoy::api::v2::filter::AccessLogFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void AccessLog::set_allocated_filter(::envoy::api::v2::filter::AccessLogFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLog.filter)
}

// .google.protobuf.Struct config = 3;
inline bool AccessLog::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void AccessLog::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) delete config_;
  config_ = NULL;
}
inline const ::google::protobuf::Struct& AccessLog::config() const {
  const ::google::protobuf::Struct* p = config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.filter.AccessLog.config)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* AccessLog::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.filter.AccessLog.config)
  return config_;
}
inline ::google::protobuf::Struct* AccessLog::release_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.filter.AccessLog.config)
  
  ::google::protobuf::Struct* temp = config_;
  config_ = NULL;
  return temp;
}
inline void AccessLog::set_allocated_config(::google::protobuf::Struct* config) {
  delete config_;
  if (config != NULL && config->GetArena() != NULL) {
    ::google::protobuf::Struct* new_config = new ::google::protobuf::Struct;
    new_config->CopyFrom(*config);
    config = new_config;
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.filter.AccessLog.config)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace filter
}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::envoy::api::v2::filter::ComparisonFilter_Op> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::filter::ComparisonFilter_Op>() {
  return ::envoy::api::v2::filter::ComparisonFilter_Op_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2ffilter_2faccesslog_2eproto__INCLUDED
