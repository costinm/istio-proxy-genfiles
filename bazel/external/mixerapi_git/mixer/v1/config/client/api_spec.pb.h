// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mixer/v1/config/client/api_spec.proto

#ifndef PROTOBUF_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto__INCLUDED
#define PROTOBUF_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include "mixer/v1/attributes.pb.h"
#include "mixer/v1/config/client/service.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHTTPAPISpecImpl();
void InitDefaultsHTTPAPISpec();
void InitDefaultsHTTPAPISpecPatternImpl();
void InitDefaultsHTTPAPISpecPattern();
void InitDefaultsAPIKeyImpl();
void InitDefaultsAPIKey();
void InitDefaultsHTTPAPISpecReferenceImpl();
void InitDefaultsHTTPAPISpecReference();
void InitDefaultsHTTPAPISpecBindingImpl();
void InitDefaultsHTTPAPISpecBinding();
inline void InitDefaults() {
  InitDefaultsHTTPAPISpec();
  InitDefaultsHTTPAPISpecPattern();
  InitDefaultsAPIKey();
  InitDefaultsHTTPAPISpecReference();
  InitDefaultsHTTPAPISpecBinding();
}
}  // namespace protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto
namespace istio {
namespace mixer {
namespace v1 {
namespace config {
namespace client {
class APIKey;
class APIKeyDefaultTypeInternal;
extern APIKeyDefaultTypeInternal _APIKey_default_instance_;
class HTTPAPISpec;
class HTTPAPISpecDefaultTypeInternal;
extern HTTPAPISpecDefaultTypeInternal _HTTPAPISpec_default_instance_;
class HTTPAPISpecBinding;
class HTTPAPISpecBindingDefaultTypeInternal;
extern HTTPAPISpecBindingDefaultTypeInternal _HTTPAPISpecBinding_default_instance_;
class HTTPAPISpecPattern;
class HTTPAPISpecPatternDefaultTypeInternal;
extern HTTPAPISpecPatternDefaultTypeInternal _HTTPAPISpecPattern_default_instance_;
class HTTPAPISpecReference;
class HTTPAPISpecReferenceDefaultTypeInternal;
extern HTTPAPISpecReferenceDefaultTypeInternal _HTTPAPISpecReference_default_instance_;
}  // namespace client
}  // namespace config
}  // namespace v1
}  // namespace mixer
}  // namespace istio
namespace istio {
namespace mixer {
namespace v1 {
namespace config {
namespace client {

// ===================================================================

class HTTPAPISpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mixer.v1.config.client.HTTPAPISpec) */ {
 public:
  HTTPAPISpec();
  virtual ~HTTPAPISpec();

  HTTPAPISpec(const HTTPAPISpec& from);

  inline HTTPAPISpec& operator=(const HTTPAPISpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPAPISpec(HTTPAPISpec&& from) noexcept
    : HTTPAPISpec() {
    *this = ::std::move(from);
  }

  inline HTTPAPISpec& operator=(HTTPAPISpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPAPISpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPAPISpec* internal_default_instance() {
    return reinterpret_cast<const HTTPAPISpec*>(
               &_HTTPAPISpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HTTPAPISpec* other);
  friend void swap(HTTPAPISpec& a, HTTPAPISpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPAPISpec* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPAPISpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPAPISpec& from);
  void MergeFrom(const HTTPAPISpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPAPISpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.mixer.v1.config.client.HTTPAPISpecPattern patterns = 2;
  int patterns_size() const;
  void clear_patterns();
  static const int kPatternsFieldNumber = 2;
  const ::istio::mixer::v1::config::client::HTTPAPISpecPattern& patterns(int index) const;
  ::istio::mixer::v1::config::client::HTTPAPISpecPattern* mutable_patterns(int index);
  ::istio::mixer::v1::config::client::HTTPAPISpecPattern* add_patterns();
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecPattern >*
      mutable_patterns();
  const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecPattern >&
      patterns() const;

  // repeated .istio.mixer.v1.config.client.APIKey api_keys = 3;
  int api_keys_size() const;
  void clear_api_keys();
  static const int kApiKeysFieldNumber = 3;
  const ::istio::mixer::v1::config::client::APIKey& api_keys(int index) const;
  ::istio::mixer::v1::config::client::APIKey* mutable_api_keys(int index);
  ::istio::mixer::v1::config::client::APIKey* add_api_keys();
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::APIKey >*
      mutable_api_keys();
  const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::APIKey >&
      api_keys() const;

  // .istio.mixer.v1.Attributes attributes = 1;
  bool has_attributes() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 1;
  const ::istio::mixer::v1::Attributes& attributes() const;
  ::istio::mixer::v1::Attributes* release_attributes();
  ::istio::mixer::v1::Attributes* mutable_attributes();
  void set_allocated_attributes(::istio::mixer::v1::Attributes* attributes);

  // @@protoc_insertion_point(class_scope:istio.mixer.v1.config.client.HTTPAPISpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecPattern > patterns_;
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::APIKey > api_keys_;
  ::istio::mixer::v1::Attributes* attributes_;
  mutable int _cached_size_;
  friend struct ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::TableStruct;
  friend void ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::InitDefaultsHTTPAPISpecImpl();
};
// -------------------------------------------------------------------

class HTTPAPISpecPattern : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mixer.v1.config.client.HTTPAPISpecPattern) */ {
 public:
  HTTPAPISpecPattern();
  virtual ~HTTPAPISpecPattern();

  HTTPAPISpecPattern(const HTTPAPISpecPattern& from);

  inline HTTPAPISpecPattern& operator=(const HTTPAPISpecPattern& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPAPISpecPattern(HTTPAPISpecPattern&& from) noexcept
    : HTTPAPISpecPattern() {
    *this = ::std::move(from);
  }

  inline HTTPAPISpecPattern& operator=(HTTPAPISpecPattern&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPAPISpecPattern& default_instance();

  enum PatternCase {
    kUriTemplate = 3,
    kRegex = 4,
    PATTERN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPAPISpecPattern* internal_default_instance() {
    return reinterpret_cast<const HTTPAPISpecPattern*>(
               &_HTTPAPISpecPattern_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HTTPAPISpecPattern* other);
  friend void swap(HTTPAPISpecPattern& a, HTTPAPISpecPattern& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPAPISpecPattern* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPAPISpecPattern* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPAPISpecPattern& from);
  void MergeFrom(const HTTPAPISpecPattern& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPAPISpecPattern* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string http_method = 2;
  void clear_http_method();
  static const int kHttpMethodFieldNumber = 2;
  const ::std::string& http_method() const;
  void set_http_method(const ::std::string& value);
  #if LANG_CXX11
  void set_http_method(::std::string&& value);
  #endif
  void set_http_method(const char* value);
  void set_http_method(const char* value, size_t size);
  ::std::string* mutable_http_method();
  ::std::string* release_http_method();
  void set_allocated_http_method(::std::string* http_method);

  // .istio.mixer.v1.Attributes attributes = 1;
  bool has_attributes() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 1;
  const ::istio::mixer::v1::Attributes& attributes() const;
  ::istio::mixer::v1::Attributes* release_attributes();
  ::istio::mixer::v1::Attributes* mutable_attributes();
  void set_allocated_attributes(::istio::mixer::v1::Attributes* attributes);

  // string uri_template = 3;
  private:
  bool has_uri_template() const;
  public:
  void clear_uri_template();
  static const int kUriTemplateFieldNumber = 3;
  const ::std::string& uri_template() const;
  void set_uri_template(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_template(::std::string&& value);
  #endif
  void set_uri_template(const char* value);
  void set_uri_template(const char* value, size_t size);
  ::std::string* mutable_uri_template();
  ::std::string* release_uri_template();
  void set_allocated_uri_template(::std::string* uri_template);

  // string regex = 4;
  private:
  bool has_regex() const;
  public:
  void clear_regex();
  static const int kRegexFieldNumber = 4;
  const ::std::string& regex() const;
  void set_regex(const ::std::string& value);
  #if LANG_CXX11
  void set_regex(::std::string&& value);
  #endif
  void set_regex(const char* value);
  void set_regex(const char* value, size_t size);
  ::std::string* mutable_regex();
  ::std::string* release_regex();
  void set_allocated_regex(::std::string* regex);

  PatternCase pattern_case() const;
  // @@protoc_insertion_point(class_scope:istio.mixer.v1.config.client.HTTPAPISpecPattern)
 private:
  void set_has_uri_template();
  void set_has_regex();

  inline bool has_pattern() const;
  void clear_pattern();
  inline void clear_has_pattern();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr http_method_;
  ::istio::mixer::v1::Attributes* attributes_;
  union PatternUnion {
    PatternUnion() {}
    ::google::protobuf::internal::ArenaStringPtr uri_template_;
    ::google::protobuf::internal::ArenaStringPtr regex_;
  } pattern_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::TableStruct;
  friend void ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::InitDefaultsHTTPAPISpecPatternImpl();
};
// -------------------------------------------------------------------

class APIKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mixer.v1.config.client.APIKey) */ {
 public:
  APIKey();
  virtual ~APIKey();

  APIKey(const APIKey& from);

  inline APIKey& operator=(const APIKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  APIKey(APIKey&& from) noexcept
    : APIKey() {
    *this = ::std::move(from);
  }

  inline APIKey& operator=(APIKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const APIKey& default_instance();

  enum KeyCase {
    kQuery = 1,
    kHeader = 2,
    kCookie = 3,
    KEY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const APIKey* internal_default_instance() {
    return reinterpret_cast<const APIKey*>(
               &_APIKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(APIKey* other);
  friend void swap(APIKey& a, APIKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline APIKey* New() const PROTOBUF_FINAL { return New(NULL); }

  APIKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const APIKey& from);
  void MergeFrom(const APIKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(APIKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string query = 1;
  private:
  bool has_query() const;
  public:
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // string header = 2;
  private:
  bool has_header() const;
  public:
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::std::string& header() const;
  void set_header(const ::std::string& value);
  #if LANG_CXX11
  void set_header(::std::string&& value);
  #endif
  void set_header(const char* value);
  void set_header(const char* value, size_t size);
  ::std::string* mutable_header();
  ::std::string* release_header();
  void set_allocated_header(::std::string* header);

  // string cookie = 3;
  private:
  bool has_cookie() const;
  public:
  void clear_cookie();
  static const int kCookieFieldNumber = 3;
  const ::std::string& cookie() const;
  void set_cookie(const ::std::string& value);
  #if LANG_CXX11
  void set_cookie(::std::string&& value);
  #endif
  void set_cookie(const char* value);
  void set_cookie(const char* value, size_t size);
  ::std::string* mutable_cookie();
  ::std::string* release_cookie();
  void set_allocated_cookie(::std::string* cookie);

  KeyCase key_case() const;
  // @@protoc_insertion_point(class_scope:istio.mixer.v1.config.client.APIKey)
 private:
  void set_has_query();
  void set_has_header();
  void set_has_cookie();

  inline bool has_key() const;
  void clear_key();
  inline void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union KeyUnion {
    KeyUnion() {}
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::google::protobuf::internal::ArenaStringPtr header_;
    ::google::protobuf::internal::ArenaStringPtr cookie_;
  } key_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::TableStruct;
  friend void ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::InitDefaultsAPIKeyImpl();
};
// -------------------------------------------------------------------

class HTTPAPISpecReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mixer.v1.config.client.HTTPAPISpecReference) */ {
 public:
  HTTPAPISpecReference();
  virtual ~HTTPAPISpecReference();

  HTTPAPISpecReference(const HTTPAPISpecReference& from);

  inline HTTPAPISpecReference& operator=(const HTTPAPISpecReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPAPISpecReference(HTTPAPISpecReference&& from) noexcept
    : HTTPAPISpecReference() {
    *this = ::std::move(from);
  }

  inline HTTPAPISpecReference& operator=(HTTPAPISpecReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPAPISpecReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPAPISpecReference* internal_default_instance() {
    return reinterpret_cast<const HTTPAPISpecReference*>(
               &_HTTPAPISpecReference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(HTTPAPISpecReference* other);
  friend void swap(HTTPAPISpecReference& a, HTTPAPISpecReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPAPISpecReference* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPAPISpecReference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPAPISpecReference& from);
  void MergeFrom(const HTTPAPISpecReference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPAPISpecReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string namespace = 2;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 2;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // @@protoc_insertion_point(class_scope:istio.mixer.v1.config.client.HTTPAPISpecReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  mutable int _cached_size_;
  friend struct ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::TableStruct;
  friend void ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::InitDefaultsHTTPAPISpecReferenceImpl();
};
// -------------------------------------------------------------------

class HTTPAPISpecBinding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mixer.v1.config.client.HTTPAPISpecBinding) */ {
 public:
  HTTPAPISpecBinding();
  virtual ~HTTPAPISpecBinding();

  HTTPAPISpecBinding(const HTTPAPISpecBinding& from);

  inline HTTPAPISpecBinding& operator=(const HTTPAPISpecBinding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPAPISpecBinding(HTTPAPISpecBinding&& from) noexcept
    : HTTPAPISpecBinding() {
    *this = ::std::move(from);
  }

  inline HTTPAPISpecBinding& operator=(HTTPAPISpecBinding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPAPISpecBinding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPAPISpecBinding* internal_default_instance() {
    return reinterpret_cast<const HTTPAPISpecBinding*>(
               &_HTTPAPISpecBinding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(HTTPAPISpecBinding* other);
  friend void swap(HTTPAPISpecBinding& a, HTTPAPISpecBinding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPAPISpecBinding* New() const PROTOBUF_FINAL { return New(NULL); }

  HTTPAPISpecBinding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HTTPAPISpecBinding& from);
  void MergeFrom(const HTTPAPISpecBinding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HTTPAPISpecBinding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.mixer.v1.config.client.IstioService services = 1;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 1;
  const ::istio::mixer::v1::config::client::IstioService& services(int index) const;
  ::istio::mixer::v1::config::client::IstioService* mutable_services(int index);
  ::istio::mixer::v1::config::client::IstioService* add_services();
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::IstioService >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::IstioService >&
      services() const;

  // repeated .istio.mixer.v1.config.client.HTTPAPISpecReference api_specs = 2;
  int api_specs_size() const;
  void clear_api_specs();
  static const int kApiSpecsFieldNumber = 2;
  const ::istio::mixer::v1::config::client::HTTPAPISpecReference& api_specs(int index) const;
  ::istio::mixer::v1::config::client::HTTPAPISpecReference* mutable_api_specs(int index);
  ::istio::mixer::v1::config::client::HTTPAPISpecReference* add_api_specs();
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecReference >*
      mutable_api_specs();
  const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecReference >&
      api_specs() const;

  // @@protoc_insertion_point(class_scope:istio.mixer.v1.config.client.HTTPAPISpecBinding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::IstioService > services_;
  ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecReference > api_specs_;
  mutable int _cached_size_;
  friend struct ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::TableStruct;
  friend void ::protobuf_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto::InitDefaultsHTTPAPISpecBindingImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HTTPAPISpec

// .istio.mixer.v1.Attributes attributes = 1;
inline bool HTTPAPISpec::has_attributes() const {
  return this != internal_default_instance() && attributes_ != NULL;
}
inline const ::istio::mixer::v1::Attributes& HTTPAPISpec::attributes() const {
  const ::istio::mixer::v1::Attributes* p = attributes_;
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpec.attributes)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::mixer::v1::Attributes*>(
      &::istio::mixer::v1::_Attributes_default_instance_);
}
inline ::istio::mixer::v1::Attributes* HTTPAPISpec::release_attributes() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpec.attributes)
  
  ::istio::mixer::v1::Attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline ::istio::mixer::v1::Attributes* HTTPAPISpec::mutable_attributes() {
  
  if (attributes_ == NULL) {
    attributes_ = new ::istio::mixer::v1::Attributes;
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpec.attributes)
  return attributes_;
}
inline void HTTPAPISpec::set_allocated_attributes(::istio::mixer::v1::Attributes* attributes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(attributes_);
  }
  if (attributes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attributes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpec.attributes)
}

// repeated .istio.mixer.v1.config.client.HTTPAPISpecPattern patterns = 2;
inline int HTTPAPISpec::patterns_size() const {
  return patterns_.size();
}
inline void HTTPAPISpec::clear_patterns() {
  patterns_.Clear();
}
inline const ::istio::mixer::v1::config::client::HTTPAPISpecPattern& HTTPAPISpec::patterns(int index) const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpec.patterns)
  return patterns_.Get(index);
}
inline ::istio::mixer::v1::config::client::HTTPAPISpecPattern* HTTPAPISpec::mutable_patterns(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpec.patterns)
  return patterns_.Mutable(index);
}
inline ::istio::mixer::v1::config::client::HTTPAPISpecPattern* HTTPAPISpec::add_patterns() {
  // @@protoc_insertion_point(field_add:istio.mixer.v1.config.client.HTTPAPISpec.patterns)
  return patterns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecPattern >*
HTTPAPISpec::mutable_patterns() {
  // @@protoc_insertion_point(field_mutable_list:istio.mixer.v1.config.client.HTTPAPISpec.patterns)
  return &patterns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecPattern >&
HTTPAPISpec::patterns() const {
  // @@protoc_insertion_point(field_list:istio.mixer.v1.config.client.HTTPAPISpec.patterns)
  return patterns_;
}

// repeated .istio.mixer.v1.config.client.APIKey api_keys = 3;
inline int HTTPAPISpec::api_keys_size() const {
  return api_keys_.size();
}
inline void HTTPAPISpec::clear_api_keys() {
  api_keys_.Clear();
}
inline const ::istio::mixer::v1::config::client::APIKey& HTTPAPISpec::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpec.api_keys)
  return api_keys_.Get(index);
}
inline ::istio::mixer::v1::config::client::APIKey* HTTPAPISpec::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpec.api_keys)
  return api_keys_.Mutable(index);
}
inline ::istio::mixer::v1::config::client::APIKey* HTTPAPISpec::add_api_keys() {
  // @@protoc_insertion_point(field_add:istio.mixer.v1.config.client.HTTPAPISpec.api_keys)
  return api_keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::APIKey >*
HTTPAPISpec::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:istio.mixer.v1.config.client.HTTPAPISpec.api_keys)
  return &api_keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::APIKey >&
HTTPAPISpec::api_keys() const {
  // @@protoc_insertion_point(field_list:istio.mixer.v1.config.client.HTTPAPISpec.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// HTTPAPISpecPattern

// .istio.mixer.v1.Attributes attributes = 1;
inline bool HTTPAPISpecPattern::has_attributes() const {
  return this != internal_default_instance() && attributes_ != NULL;
}
inline const ::istio::mixer::v1::Attributes& HTTPAPISpecPattern::attributes() const {
  const ::istio::mixer::v1::Attributes* p = attributes_;
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecPattern.attributes)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::mixer::v1::Attributes*>(
      &::istio::mixer::v1::_Attributes_default_instance_);
}
inline ::istio::mixer::v1::Attributes* HTTPAPISpecPattern::release_attributes() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecPattern.attributes)
  
  ::istio::mixer::v1::Attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline ::istio::mixer::v1::Attributes* HTTPAPISpecPattern::mutable_attributes() {
  
  if (attributes_ == NULL) {
    attributes_ = new ::istio::mixer::v1::Attributes;
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecPattern.attributes)
  return attributes_;
}
inline void HTTPAPISpecPattern::set_allocated_attributes(::istio::mixer::v1::Attributes* attributes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(attributes_);
  }
  if (attributes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attributes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecPattern.attributes)
}

// string http_method = 2;
inline void HTTPAPISpecPattern::clear_http_method() {
  http_method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPAPISpecPattern::http_method() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
  return http_method_.GetNoArena();
}
inline void HTTPAPISpecPattern::set_http_method(const ::std::string& value) {
  
  http_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
}
#if LANG_CXX11
inline void HTTPAPISpecPattern::set_http_method(::std::string&& value) {
  
  http_method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
}
#endif
inline void HTTPAPISpecPattern::set_http_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  http_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
}
inline void HTTPAPISpecPattern::set_http_method(const char* value, size_t size) {
  
  http_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
}
inline ::std::string* HTTPAPISpecPattern::mutable_http_method() {
  
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
  return http_method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPAPISpecPattern::release_http_method() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
  
  return http_method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPAPISpecPattern::set_allocated_http_method(::std::string* http_method) {
  if (http_method != NULL) {
    
  } else {
    
  }
  http_method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), http_method);
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecPattern.http_method)
}

// string uri_template = 3;
inline bool HTTPAPISpecPattern::has_uri_template() const {
  return pattern_case() == kUriTemplate;
}
inline void HTTPAPISpecPattern::set_has_uri_template() {
  _oneof_case_[0] = kUriTemplate;
}
inline void HTTPAPISpecPattern::clear_uri_template() {
  if (has_uri_template()) {
    pattern_.uri_template_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_pattern();
  }
}
inline const ::std::string& HTTPAPISpecPattern::uri_template() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
  if (has_uri_template()) {
    return pattern_.uri_template_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void HTTPAPISpecPattern::set_uri_template(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
  if (!has_uri_template()) {
    clear_pattern();
    set_has_uri_template();
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
}
#if LANG_CXX11
inline void HTTPAPISpecPattern::set_uri_template(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
  if (!has_uri_template()) {
    clear_pattern();
    set_has_uri_template();
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.uri_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
}
#endif
inline void HTTPAPISpecPattern::set_uri_template(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri_template()) {
    clear_pattern();
    set_has_uri_template();
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
}
inline void HTTPAPISpecPattern::set_uri_template(const char* value, size_t size) {
  if (!has_uri_template()) {
    clear_pattern();
    set_has_uri_template();
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
}
inline ::std::string* HTTPAPISpecPattern::mutable_uri_template() {
  if (!has_uri_template()) {
    clear_pattern();
    set_has_uri_template();
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
  return pattern_.uri_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPAPISpecPattern::release_uri_template() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
  if (has_uri_template()) {
    clear_has_pattern();
    return pattern_.uri_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void HTTPAPISpecPattern::set_allocated_uri_template(::std::string* uri_template) {
  if (!has_uri_template()) {
    pattern_.uri_template_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_pattern();
  if (uri_template != NULL) {
    set_has_uri_template();
    pattern_.uri_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        uri_template);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecPattern.uri_template)
}

// string regex = 4;
inline bool HTTPAPISpecPattern::has_regex() const {
  return pattern_case() == kRegex;
}
inline void HTTPAPISpecPattern::set_has_regex() {
  _oneof_case_[0] = kRegex;
}
inline void HTTPAPISpecPattern::clear_regex() {
  if (has_regex()) {
    pattern_.regex_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_pattern();
  }
}
inline const ::std::string& HTTPAPISpecPattern::regex() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
  if (has_regex()) {
    return pattern_.regex_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void HTTPAPISpecPattern::set_regex(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
  if (!has_regex()) {
    clear_pattern();
    set_has_regex();
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
}
#if LANG_CXX11
inline void HTTPAPISpecPattern::set_regex(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
  if (!has_regex()) {
    clear_pattern();
    set_has_regex();
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.regex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
}
#endif
inline void HTTPAPISpecPattern::set_regex(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_regex()) {
    clear_pattern();
    set_has_regex();
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
}
inline void HTTPAPISpecPattern::set_regex(const char* value, size_t size) {
  if (!has_regex()) {
    clear_pattern();
    set_has_regex();
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  pattern_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
}
inline ::std::string* HTTPAPISpecPattern::mutable_regex() {
  if (!has_regex()) {
    clear_pattern();
    set_has_regex();
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
  return pattern_.regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPAPISpecPattern::release_regex() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
  if (has_regex()) {
    clear_has_pattern();
    return pattern_.regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void HTTPAPISpecPattern::set_allocated_regex(::std::string* regex) {
  if (!has_regex()) {
    pattern_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_pattern();
  if (regex != NULL) {
    set_has_regex();
    pattern_.regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        regex);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecPattern.regex)
}

inline bool HTTPAPISpecPattern::has_pattern() const {
  return pattern_case() != PATTERN_NOT_SET;
}
inline void HTTPAPISpecPattern::clear_has_pattern() {
  _oneof_case_[0] = PATTERN_NOT_SET;
}
inline HTTPAPISpecPattern::PatternCase HTTPAPISpecPattern::pattern_case() const {
  return HTTPAPISpecPattern::PatternCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// APIKey

// string query = 1;
inline bool APIKey::has_query() const {
  return key_case() == kQuery;
}
inline void APIKey::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void APIKey::clear_query() {
  if (has_query()) {
    key_.query_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_key();
  }
}
inline const ::std::string& APIKey::query() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.APIKey.query)
  if (has_query()) {
    return key_.query_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void APIKey::set_query(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.query)
  if (!has_query()) {
    clear_key();
    set_has_query();
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.query)
}
#if LANG_CXX11
inline void APIKey::set_query(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.query)
  if (!has_query()) {
    clear_key();
    set_has_query();
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.APIKey.query)
}
#endif
inline void APIKey::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_query()) {
    clear_key();
    set_has_query();
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.APIKey.query)
}
inline void APIKey::set_query(const char* value, size_t size) {
  if (!has_query()) {
    clear_key();
    set_has_query();
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.APIKey.query)
}
inline ::std::string* APIKey::mutable_query() {
  if (!has_query()) {
    clear_key();
    set_has_query();
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.APIKey.query)
  return key_.query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* APIKey::release_query() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.APIKey.query)
  if (has_query()) {
    clear_has_key();
    return key_.query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void APIKey::set_allocated_query(::std::string* query) {
  if (!has_query()) {
    key_.query_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_key();
  if (query != NULL) {
    set_has_query();
    key_.query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        query);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.APIKey.query)
}

// string header = 2;
inline bool APIKey::has_header() const {
  return key_case() == kHeader;
}
inline void APIKey::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void APIKey::clear_header() {
  if (has_header()) {
    key_.header_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_key();
  }
}
inline const ::std::string& APIKey::header() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.APIKey.header)
  if (has_header()) {
    return key_.header_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void APIKey::set_header(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.header)
  if (!has_header()) {
    clear_key();
    set_has_header();
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.header)
}
#if LANG_CXX11
inline void APIKey::set_header(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.header)
  if (!has_header()) {
    clear_key();
    set_has_header();
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.APIKey.header)
}
#endif
inline void APIKey::set_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_header()) {
    clear_key();
    set_has_header();
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.APIKey.header)
}
inline void APIKey::set_header(const char* value, size_t size) {
  if (!has_header()) {
    clear_key();
    set_has_header();
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.APIKey.header)
}
inline ::std::string* APIKey::mutable_header() {
  if (!has_header()) {
    clear_key();
    set_has_header();
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.APIKey.header)
  return key_.header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* APIKey::release_header() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.APIKey.header)
  if (has_header()) {
    clear_has_key();
    return key_.header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void APIKey::set_allocated_header(::std::string* header) {
  if (!has_header()) {
    key_.header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_key();
  if (header != NULL) {
    set_has_header();
    key_.header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        header);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.APIKey.header)
}

// string cookie = 3;
inline bool APIKey::has_cookie() const {
  return key_case() == kCookie;
}
inline void APIKey::set_has_cookie() {
  _oneof_case_[0] = kCookie;
}
inline void APIKey::clear_cookie() {
  if (has_cookie()) {
    key_.cookie_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_key();
  }
}
inline const ::std::string& APIKey::cookie() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.APIKey.cookie)
  if (has_cookie()) {
    return key_.cookie_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void APIKey::set_cookie(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.cookie)
  if (!has_cookie()) {
    clear_key();
    set_has_cookie();
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.cookie)
}
#if LANG_CXX11
inline void APIKey::set_cookie(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.APIKey.cookie)
  if (!has_cookie()) {
    clear_key();
    set_has_cookie();
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.cookie_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.APIKey.cookie)
}
#endif
inline void APIKey::set_cookie(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_cookie()) {
    clear_key();
    set_has_cookie();
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.APIKey.cookie)
}
inline void APIKey::set_cookie(const char* value, size_t size) {
  if (!has_cookie()) {
    clear_key();
    set_has_cookie();
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  key_.cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.APIKey.cookie)
}
inline ::std::string* APIKey::mutable_cookie() {
  if (!has_cookie()) {
    clear_key();
    set_has_cookie();
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.APIKey.cookie)
  return key_.cookie_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* APIKey::release_cookie() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.APIKey.cookie)
  if (has_cookie()) {
    clear_has_key();
    return key_.cookie_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void APIKey::set_allocated_cookie(::std::string* cookie) {
  if (!has_cookie()) {
    key_.cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_key();
  if (cookie != NULL) {
    set_has_cookie();
    key_.cookie_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        cookie);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.APIKey.cookie)
}

inline bool APIKey::has_key() const {
  return key_case() != KEY_NOT_SET;
}
inline void APIKey::clear_has_key() {
  _oneof_case_[0] = KEY_NOT_SET;
}
inline APIKey::KeyCase APIKey::key_case() const {
  return APIKey::KeyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HTTPAPISpecReference

// string name = 1;
inline void HTTPAPISpecReference::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPAPISpecReference::name() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
  return name_.GetNoArena();
}
inline void HTTPAPISpecReference::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
}
#if LANG_CXX11
inline void HTTPAPISpecReference::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
}
#endif
inline void HTTPAPISpecReference::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
}
inline void HTTPAPISpecReference::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
}
inline ::std::string* HTTPAPISpecReference::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPAPISpecReference::release_name() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPAPISpecReference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecReference.name)
}

// string namespace = 2;
inline void HTTPAPISpecReference::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HTTPAPISpecReference::namespace_() const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
  return namespace__.GetNoArena();
}
inline void HTTPAPISpecReference::set_namespace_(const ::std::string& value) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
}
#if LANG_CXX11
inline void HTTPAPISpecReference::set_namespace_(::std::string&& value) {
  
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
}
#endif
inline void HTTPAPISpecReference::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
}
inline void HTTPAPISpecReference::set_namespace_(const char* value, size_t size) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
}
inline ::std::string* HTTPAPISpecReference::mutable_namespace_() {
  
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HTTPAPISpecReference::release_namespace_() {
  // @@protoc_insertion_point(field_release:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
  
  return namespace__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HTTPAPISpecReference::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    
  } else {
    
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:istio.mixer.v1.config.client.HTTPAPISpecReference.namespace)
}

// -------------------------------------------------------------------

// HTTPAPISpecBinding

// repeated .istio.mixer.v1.config.client.IstioService services = 1;
inline int HTTPAPISpecBinding::services_size() const {
  return services_.size();
}
inline const ::istio::mixer::v1::config::client::IstioService& HTTPAPISpecBinding::services(int index) const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecBinding.services)
  return services_.Get(index);
}
inline ::istio::mixer::v1::config::client::IstioService* HTTPAPISpecBinding::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecBinding.services)
  return services_.Mutable(index);
}
inline ::istio::mixer::v1::config::client::IstioService* HTTPAPISpecBinding::add_services() {
  // @@protoc_insertion_point(field_add:istio.mixer.v1.config.client.HTTPAPISpecBinding.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::IstioService >*
HTTPAPISpecBinding::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:istio.mixer.v1.config.client.HTTPAPISpecBinding.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::IstioService >&
HTTPAPISpecBinding::services() const {
  // @@protoc_insertion_point(field_list:istio.mixer.v1.config.client.HTTPAPISpecBinding.services)
  return services_;
}

// repeated .istio.mixer.v1.config.client.HTTPAPISpecReference api_specs = 2;
inline int HTTPAPISpecBinding::api_specs_size() const {
  return api_specs_.size();
}
inline void HTTPAPISpecBinding::clear_api_specs() {
  api_specs_.Clear();
}
inline const ::istio::mixer::v1::config::client::HTTPAPISpecReference& HTTPAPISpecBinding::api_specs(int index) const {
  // @@protoc_insertion_point(field_get:istio.mixer.v1.config.client.HTTPAPISpecBinding.api_specs)
  return api_specs_.Get(index);
}
inline ::istio::mixer::v1::config::client::HTTPAPISpecReference* HTTPAPISpecBinding::mutable_api_specs(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mixer.v1.config.client.HTTPAPISpecBinding.api_specs)
  return api_specs_.Mutable(index);
}
inline ::istio::mixer::v1::config::client::HTTPAPISpecReference* HTTPAPISpecBinding::add_api_specs() {
  // @@protoc_insertion_point(field_add:istio.mixer.v1.config.client.HTTPAPISpecBinding.api_specs)
  return api_specs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecReference >*
HTTPAPISpecBinding::mutable_api_specs() {
  // @@protoc_insertion_point(field_mutable_list:istio.mixer.v1.config.client.HTTPAPISpecBinding.api_specs)
  return &api_specs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mixer::v1::config::client::HTTPAPISpecReference >&
HTTPAPISpecBinding::api_specs() const {
  // @@protoc_insertion_point(field_list:istio.mixer.v1.config.client.HTTPAPISpecBinding.api_specs)
  return api_specs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace client
}  // namespace config
}  // namespace v1
}  // namespace mixer
}  // namespace istio

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mixer_2fv1_2fconfig_2fclient_2fapi_5fspec_2eproto__INCLUDED
